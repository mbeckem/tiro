#!/usr/bin/env python3
#
# This script generates the ast class hierarchy used in the compiler.
# Invoke this script from the main project directory - it uses relative paths.

import datetime
import re
import subprocess
import sys

from itertools import chain
from textwrap import indent as text_indent, dedent


class Node:
    def __init__(self, name, base_type="Node", abstract=False, generate=True, members=None, additonal_base_types=[]):
        self.name = name
        self.snake_name = camel_to_snake(name)  # for visitor function names
        self.base_type = base_type
        self.abstract = abstract
        self.generate = generate
        self.members = members if members is not None else []
        self.additional_base_types = additonal_base_types


# Taken from https://stackoverflow.com/a/1176023
first_cap_re = re.compile('(.)([A-Z][a-z]+)')
all_cap_re = re.compile('([a-z0-9])([A-Z])')


def camel_to_snake(name):
    s1 = first_cap_re.sub(r'\1_\2', name)
    return all_cap_re.sub(r'\1_\2', s1).lower()


class BaseType:
    def __init__(self, name, traverse_fn=None, transform_fn=None):
        self.name = name
        self.traverse_fn = traverse_fn
        self.transform_fn = transform_fn


def list_base(node_type):
    type_name = f"NodeListBase<{node_type}>"
    traverse_fn = f"NodeListTraits<{node_type}>::traverse_items"
    transform_fn = f"NodeListTraits<{node_type}>::transform_items"
    return BaseType(type_name, traverse_fn, transform_fn)


class Member:
    def __init__(self, name, doc=None, settable=True, mutable=False):
        self.name = name
        self.field_name = name + "_"
        self.settable = settable
        self.mutable = mutable
        self.doc = doc


class DataMember(Member):
    def __init__(self, name, data_type, default_value="", in_constructor=False, **kwargs):
        super().__init__(name, **kwargs)
        self.in_constructor = in_constructor
        self.default_value = default_value
        self.data_type = data_type


class NodeChildMember(Member):
    def __init__(self, name, node_type, **kwargs):
        super().__init__(name, **kwargs)
        self.node_type = node_type
        self.pointer_type = f"NodePtr<{node_type}>"


# TODO different inner and outer types  (shared <-> weak)
class WeakMember(Member):
    def __init__(self, name, strong_type, weak_type, **kwargs):
        super().__init__(name, **kwargs)
        self.strong_type = strong_type
        self.weak_type = weak_type


def visit_member(member, visitor):
    typename = type(member).__name__
    visit = getattr(visitor, f"visit_{typename}")
    return visit(member)


def array_member(name, element_type, **kwargs):
    return DataMember(name, f"std::vector<{element_type}>", default_value="", settable=False, mutable=True, **kwargs)


class ClassTreeItem:
    def __init__(self, type):
        self.id = None
        self.type = type
        self.parent = None
        self.children = []


def walk_tree(item):
    if not item:
        return
    yield item
    for child in sorted(item.children, key=lambda item: item.type.name):
        yield from walk_tree(child)


def walk_leaves(item):
    for i in walk_tree(item):
        if not i.type.abstract:
            yield i


def walk_nodes(item):
    for i in walk_tree(item):
        if i.type.abstract:
            yield i


NODE_TYPES = [
    Node("Node", base_type=None, abstract=True, generate=False),

    Node("NodeList", "Node", additonal_base_types=[list_base("Node")]),
    Node("ExprList", "Node", additonal_base_types=[list_base("Expr")]),
    Node("StmtList", "Node", additonal_base_types=[list_base("Stmt")]),
    Node("ParamList", "Node", additonal_base_types=[
        list_base("ParamDecl")
    ]),
    Node("VarList", "Node", additonal_base_types=[list_base("VarDecl")]),
    Node("BindingList", "Node", additonal_base_types=[list_base("Binding")]),

    Node("MapEntryList", "Node", additonal_base_types=[
        list_base("MapEntry")]),

    Node("Root", members=[
        NodeChildMember("file", "File"),
        WeakMember("root_scope", "ScopePtr", "WeakScopePtr"),
    ]),

    Node("File", members=[
        DataMember("file_name", "InternedString"),
        NodeChildMember("items", "NodeList", doc="items at top level"),
        WeakMember("file_scope", "ScopePtr", "WeakScopePtr")
    ]),

    Node("MapEntry", members=[
        NodeChildMember("key", "Expr"),
        NodeChildMember("value", "Expr")
    ]),

    Node("Binding", abstract=True, members=[
        NodeChildMember("init", "Expr")
    ]),

    Node("VarBinding", "Binding", members=[
        NodeChildMember("var", "VarDecl")
    ]),

    Node("TupleBinding", "Binding", members=[
        NodeChildMember("vars", "VarList")
    ]),

    Node("Decl", abstract=True, members=[
        DataMember("name", "InternedString", doc="invalid if anonymous"),
        WeakMember("declared_symbol", "SymbolEntryPtr", "WeakSymbolEntryPtr"),
    ]),

    Node("VarDecl", "Decl", members=[
        DataMember("is_const", "bool")
    ]),

    Node("FuncDecl", "Decl", members=[
        NodeChildMember("params", "ParamList"),
        NodeChildMember("body", "Expr"),
        WeakMember("param_scope", "ScopePtr", "WeakScopePtr"),
        WeakMember("body_scope", "ScopePtr", "WeakScopePtr"),
    ]),

    Node("ParamDecl", "Decl"),

    Node("ImportDecl", "Decl", members=[
        array_member("path_elements", "InternedString")
    ]),

    Node("Stmt", abstract=True),

    Node("EmptyStmt", "Stmt"),

    Node("AssertStmt", "Stmt", members=[
        NodeChildMember("condition", "Expr"),
        NodeChildMember(
            "message", "Expr", doc="optional, either interpolated string or string literal")
    ]),

    Node("WhileStmt", "Stmt", members=[
        NodeChildMember("condition", "Expr"),
        NodeChildMember("body", "BlockExpr"),
        WeakMember("body_scope", "ScopePtr", "WeakScopePtr"),
    ]),

    Node("ForStmt", "Stmt", members=[
        NodeChildMember("decl", "DeclStmt", doc="optional"),
        NodeChildMember("condition", "Expr", doc="optional"),
        NodeChildMember("step", "Expr", doc="optional"),
        NodeChildMember("body", "Expr"),
        WeakMember("decl_scope", "ScopePtr", "WeakScopePtr"),
        WeakMember("body_scope", "ScopePtr", "WeakScopePtr"),
    ]),

    Node("DeclStmt", "Stmt", members=[
        NodeChildMember("bindings", "BindingList")
    ]),

    Node("ExprStmt", "Stmt", members=[
        NodeChildMember("expr", "Expr"),
    ]),

    Node("Expr", abstract=True, members=[
        DataMember("expr_type", "ExprType", default_value="ExprType::None"),
        DataMember("observed", "bool", default_value="true"),
        WeakMember("surrounding_scope", "ScopePtr", "WeakScopePtr"),
    ]),

    Node("BlockExpr", "Expr", members=[
        NodeChildMember("stmts", "StmtList"),
        WeakMember("block_scope", "ScopePtr", "WeakScopePtr"),
    ]),

    Node("UnaryExpr", "Expr", members=[
        DataMember("operation", "UnaryOperator", in_constructor=True),
        NodeChildMember("inner", "Expr")
    ]),

    Node("BinaryExpr", "Expr", members=[
        DataMember("operation", "BinaryOperator", in_constructor=True),
        NodeChildMember("left", "Expr"),
        NodeChildMember("right", "Expr")
    ]),

    Node("VarExpr", "Expr", members=[
        DataMember("name", "InternedString", in_constructor=True),
        WeakMember("resolved_symbol", "SymbolEntryPtr", "WeakSymbolEntryPtr"),
    ]),

    Node("DotExpr", "Expr", members=[
        NodeChildMember("inner", "Expr"),
        DataMember("name", "InternedString")
    ]),

    Node("TupleMemberExpr", "Expr", members=[
        NodeChildMember("inner", "Expr"),
        DataMember("index", "u32")
    ]),

    Node("CallExpr", "Expr", members=[
        NodeChildMember("func", "Expr"),
        NodeChildMember("args", "ExprList")
    ]),

    Node("IndexExpr", "Expr", members=[
        NodeChildMember("inner", "Expr"),
        NodeChildMember("index", "Expr")
    ]),

    Node("IfExpr", "Expr", members=[
        NodeChildMember("condition", "Expr"),
        NodeChildMember("then_branch", "Expr"),
        NodeChildMember("else_branch", "Expr")
    ]),

    Node("ReturnExpr", "Expr", members=[
        NodeChildMember("inner", "Expr")
    ]),

    Node("ContinueExpr", "Expr"),

    Node("BreakExpr", "Expr"),

    Node("StringSequenceExpr", "Expr", members=[
        NodeChildMember("strings", "ExprList")
    ]),

    Node("InterpolatedStringExpr", "Expr", members=[
        NodeChildMember("items", "ExprList")
    ]),

    Node("Literal", "Expr", abstract=True),

    Node("NullLiteral", "Literal"),

    Node("BooleanLiteral", "Literal", members=[
        DataMember("value", "bool", in_constructor=True)
    ]),

    Node("IntegerLiteral", "Literal", members=[
        DataMember("value", "i64", in_constructor=True)
    ]),

    Node("FloatLiteral", "Literal", members=[
        DataMember("value", "f64", in_constructor=True)
    ]),

    Node("StringLiteral", "Literal", members=[
        DataMember("value", "InternedString", in_constructor=True)
    ]),

    Node("SymbolLiteral", "Literal", members=[
        DataMember("value", "InternedString", in_constructor=True)
    ]),

    Node("ArrayLiteral", "Literal", members=[
        NodeChildMember("entries", "ExprList")
    ]),

    Node("TupleLiteral", "Literal", members=[
        NodeChildMember("entries", "ExprList")
    ]),

    Node("MapLiteral", "Literal", members=[
        NodeChildMember("entries", "MapEntryList")
    ]),

    Node("SetLiteral", "Literal", members=[
        NodeChildMember("entries", "ExprList")
    ]),

    Node("FuncLiteral", "Literal", members=[
        NodeChildMember("func", "FuncDecl")
    ])
]


def main():
    types = list(sorted(NODE_TYPES, key=lambda type: type.name))
    root = class_tree(types, "Node")

    HEADER_PATH = "./src/tiro/syntax/ast.generated.hpp"
    IPP_PATH = "./src/tiro/syntax/ast.generated.ipp"
    CPP_PATH = "./src/tiro/syntax/ast.generated.cpp"

    with open(HEADER_PATH, "w+", encoding="utf-8") as stream:
        print(f"Generating {HEADER_PATH}")
        header(stream, root)

    with open(IPP_PATH, "w+", encoding="utf-8") as stream:
        print(f"Generating {IPP_PATH}")
        ipp(stream, root)

    with open(CPP_PATH, "w+", encoding="utf-8") as stream:
        print(f"Generating {CPP_PATH}")
        cpp(stream, root)

    for path in [HEADER_PATH, IPP_PATH, CPP_PATH]:
        print(f"Formatting {path}")
        subprocess.check_call(["clang-format", "-style=file", "-i", path])

    print("Done")


def class_tree(types, base_type):
    items = {
        type.name: ClassTreeItem(type)
        for type in types
    }

    for type in types:
        if not type.base_type:
            continue

        base = items.get(type.base_type)
        if not base.type.abstract:
            raise RuntimeError(
                f"Type {type.name} must not inherit "
                f"from non-abstract base {type.base_type}")

        item = items.get(type.name)
        item.parent = base
        base.children.append(item)

    next_id = 1

    def assign_ids(item):
        nonlocal next_id
        if item.type.abstract:
            if len(item.children) == 0:
                raise RuntimeError(
                    f"Abstract type {item.type.name} does not have any child types.")

            for child in item.children:
                assign_ids(child)

            first = item.children[0].id
            if isinstance(first, tuple):
                first = first[0]

            last = item.children[-1].id
            if isinstance(last, tuple):
                last = last[1]

            item.id = (first, last)
        else:
            item.id = next_id
            next_id += 1

    root = items.get(base_type)
    assign_ids(root)
    return root


def header(stream, root):
    template = """\
        {prefix}

        namespace tiro::compiler {{

        {forward_decls}

        {type_enum}

        {classes}

        {visitor}

        }} // namespace tiro::compiler
    """

    classes = list(class_body(item)
                   for item in walk_tree(root) if item.type.generate)

    stream.write(dedent(template).format(
        prefix=prefix(),
        forward_decls=forward_decls(root),
        type_enum=type_enum(root),
        classes="\n\n".join(classes),
        visitor=visitor_impl(root)
    ))


def ipp(stream, root):
    template = """\
        {prefix}

        namespace tiro::compiler {{

        {visit}

        {downcast}

        {traits}

        }} // namespace tiro::compiler
    """

    traits = list(class_traits(item)
                  for item in walk_tree(root) if item.type.generate)

    stream.write(dedent(template).format(
        prefix=prefix(),
        visit=visit_impl(root),
        downcast=downcast_impl(root),
        traits="\n\n".join(traits)
    ))


def cpp(stream, root):
    template = """\
        {prefix}

        # include "tiro/syntax/ast.hpp"
        # include "tiro/semantics/symbol_table.hpp" // Ugh :/

        # include <utility>

        namespace tiro::compiler {{

        {type_enum_to_string}

        {classes}

        }} // namespace tiro::compiler
    """

    classes = list(class_impl(item)
                   for item in walk_tree(root) if item.type.generate)

    stream.write(dedent(template).format(
        prefix=prefix(),
        type_enum_to_string=type_enum_to_string(root),
        classes="\n\n".join(classes)
    ))


def forward_decls(root):
    items = sorted(walk_tree(root), key=lambda item: item.type.name)
    return "\n".join(f"class {item.type.name};" for item in items)


def type_enum(root):
    template = """\
        enum class NodeType : int {{
        {types}
        }};"""

    enumlist = []

    def walk(item):
        if item.type.abstract:
            for child in item.children:
                walk(child)
            enumlist.append((f"First{item.type.name} = {item.id[0]}"))
            enumlist.append((f"Last{item.type.name} = {item.id[1]}"))
        else:
            enumlist.append(f"{item.type.name} = {item.id}")
    walk(root)

    types = ",\n".join(indent(enum, 1) for enum in enumlist)
    return dedent(template).format(types=types)


def type_enum_to_string(root):
    template = """\
        std::string_view to_string(NodeType type) {{
            switch (type) {{
        {cases}
            }}
            TIRO_UNREACHABLE("Invalid node type.");
        }}"""

    cases = list(f"case NodeType::{item.type.name}: return \"{item.type.name}\";"
                 for item in walk_leaves(root))
    return dedent(template).format(cases=indent("\n".join(cases), 1))


def class_body(item):
    class_template = """\
        class {class_name} {maybe_final}: {base_classes} {{
        {constructor}
        {destructor}

        {accessors}

        private:
        {fields}
        }};"""

    class_name = item.type.name

    base_list = [item.type.base_type] + \
        [bt.name for bt in item.type.additional_base_types]
    base_classes = ", ".join(f"public {base}" for base in base_list)

    arglist = ["NodeType child_type"] if item.type.abstract else []
    for member in chain(parent_constructor_members(item), constructor_members(item)):
        if not isinstance(member, DataMember):
            raise RuntimeError(
                "Constructor properties only implemented for data members as of yet")
        arglist.append(f"{member.data_type} {member.name}")
    constructor_args = ", ".join(arglist)

    if item.type.abstract:
        constructor_template = """\
            protected:
                explicit {class_name}({constructor_args});

            public:"""
    else:
        constructor_template = """\
            public:
                explicit {class_name}({constructor_args});"""
    constructor = dedent(constructor_template).format(
        class_name=class_name, constructor_args=constructor_args)

    destructor = indent(f"~{item.type.name}();", 1)
    accessors = "\n\n".join(indent(member_decl(item.type, member), 1)
                            for member in item.type.members)
    fields = "\n".join(indent(f"{member_storage_type(member)} {member.field_name};", 1)
                       for member in item.type.members)

    return dedent(class_template).format(
        class_name=class_name, base_classes=base_classes,
        maybe_final="final" if not item.type.abstract else "",
        constructor=constructor, destructor=destructor,
        accessors=accessors, fields=fields)


def class_traits(item):
    template = """\
        template<>
        struct NodeTraits<{class_name}> {{
            static constexpr bool is_abstract = {is_abstract};

        {type_ids}

            template<typename Visitor>
            static void traverse_children({class_name}* node, Visitor&& visitor) {{
                NodeTraits<{base_type}>::traverse_children(node, visitor);
        {traverse_additional_bases}
        {traverse_children}
            }}

            template<typename Transform>
            static void transform_children({class_name}* node, Transform&& transform) {{
                NodeTraits<{base_type}>::transform_children(node, transform);
        {transform_additional_bases}
        {transform_children}
            }}
        }};"""

    if item.type.abstract:
        type_ids = indent(f"static constexpr NodeType first_node_type = NodeType::First{item.type.name};\n"
                          f"static constexpr NodeType last_node_type = NodeType::Last{item.type.name};", 1)
    else:
        type_ids = indent(
            f"static constexpr NodeType node_type = NodeType::{item.type.name};", 1)

    traverse_additional_bases = list(f"{base.traverse_fn}(node, visitor);"
                                     for base in item.type.additional_base_types
                                     if base.traverse_fn)
    traverse_children = list(f"visitor(node->{member.name}());"
                             for member in item.type.members
                             if isinstance(member, NodeChildMember))

    transform_additional_bases = list(f"{base.transform_fn}(node, transform);"
                                      for base in item.type.additional_base_types
                                      if base.transform_fn)
    transform_children = list(f"node->{member.name}(must_cast_nullable<{member.node_type}>(transform(node->{member.name}())));"
                              for member in item.type.members
                              if isinstance(member, NodeChildMember) and member.settable)

    return dedent(template).format(
        class_name=item.type.name,
        base_type=item.type.base_type,
        is_abstract="true" if item.type.abstract else "false",
        type_ids=type_ids,
        traverse_additional_bases=indent(
            "\n".join(traverse_additional_bases), 2),
        traverse_children=indent("\n".join(traverse_children), 2),
        transform_additional_bases=indent(
            "\n".join(transform_additional_bases), 2),
        transform_children=indent("\n".join(transform_children), 2)
    )


def class_impl(item):
    items = []
    items.append(constructor_impl(item))
    items.append(f"{item.type.name}::~{item.type.name}() {{}}")
    items.extend(member_impl(item.type, member)
                 for member in item.type.members)

    return "\n\n".join(items)


def constructor_impl(item):
    template = """\
        {class_name}::{class_name}({arglist})
        {initializers}
        {{
        {body}
        }}"""

    arglist = ["NodeType child_type"] if item.type.abstract else []
    for member in chain(parent_constructor_members(item), constructor_members(item)):
        if not isinstance(member, DataMember):
            raise RuntimeError(
                "Constructor properties only implemented for data members as of yet")
        arglist.append(f"{member.data_type} {member.name}")

    base_arglist = ["child_type" if item.type.abstract else
                    f"NodeType::{item.type.name}"]
    base_arglist.extend(
        f"std::move({member.name})" for member in parent_constructor_members(item))

    initializers = [
        ": {base_type}({base_arglist})".format(
            base_type=item.type.base_type,
            base_arglist=", ".join(base_arglist))
    ]
    for member in item.type.members:
        init = ""
        if isinstance(member, DataMember):
            if member.in_constructor:
                init = f"std::move({member.name})"
            elif member.default_value:
                init = member.default_value

        initializers.append(f", {member.field_name}({init})")

    body = ""
    if item.type.abstract:
        body = f"TIRO_ASSERT(child_type >= NodeType::First{item.type.name} && "\
               f"child_type <= NodeType::Last{item.type.name}, \"Invalid child type.\");"

    return dedent(template).format(
        class_name=item.type.name,
        arglist=", ".join(arglist),
        base_type=item.type.base_type,
        base_arglist=", ".join(base_arglist),
        initializers=indent("\n".join(initializers), 1),
        body=indent(body, 1)
    )


def member_decl(type, member):
    lines = []

    if member.doc:
        lines.append(f"// {member.doc}")

    if member.mutable:
        class Visitor:
            def visit_DataMember(self, member):
                return f"{member.data_type}& {member.name}() {{ return {member.field_name}; }}"
            # other types are errors
        lines.append(visit_member(member, Visitor()))
    else:
        accessor_type = member_accessor_type(member)
        if member.settable:
            lines.append(
                f"void {member.name}({accessor_type} value);")
        lines.append(f"{accessor_type} {member.name}() const;")

    return "\n".join(lines)


def member_impl(class_type, member):
    accessors = []

    if member.mutable:
        return ""

    if member.settable:
        assignment = ""
        if isinstance(member, NodeChildMember):
            assignment = f"{member.field_name}.reset(value);"
        else:
            assignment = f"{member.field_name} = value;"

        setter_template = dedent("""\
            void {class_name}::{member_name}({accessor_type} value) {{
                {assignment}
            }}""")
        accessors.append(setter_template.format(
            class_name=class_type.name,
            member_name=member.name,
            accessor_type=member_accessor_type(member),
            assignment=assignment,
        ))

    class GetterVisitor:
        def visit_DataMember(self, member):
            return f"return {member.field_name};"

        def visit_NodeChildMember(self, member):
            return f"return {member.field_name};"

        def visit_WeakMember(self, member):
            return f"return {member.field_name}.lock();"

    getter_template = dedent("""\
        {accessor_type} {class_name}::{member_name}() const {{
            {body}
        }}""")
    accessors.append(getter_template.format(class_name=class_type.name,
                                            member_name=member.name,
                                            accessor_type=member_accessor_type(
                                                member),
                                            body=visit_member(member, GetterVisitor())))
    return "\n\n".join(accessors)


def member_accessor_type(member):
    class Visitor:
        def visit_DataMember(self, member):
            return f"const {member.data_type}&"

        def visit_NodeChildMember(self, member):
            return f"{member.node_type}*"

        def visit_WeakMember(self, member):
            return member.strong_type

    return visit_member(member, Visitor())


def member_storage_type(member):
    class Visitor:
        def visit_DataMember(self, member):
            return member.data_type

        def visit_NodeChildMember(self, member):
            return member.pointer_type

        def visit_WeakMember(self, member):
            return member.weak_type

    return visit_member(member, Visitor())


def visitor_impl(root):
    template = """
        template<typename Derived, typename... Arguments>
        class DefaultNodeVisitor {{
        public:
            DefaultNodeVisitor() = default;

            TIRO_VISITOR_DECL ~DefaultNodeVisitor() = default;

        {functions}

        private:
            Derived& derived() {{ return static_cast<Derived&>(*this); }}
        }};"""

    function_template = dedent("""\
        TIRO_VISITOR_DECL void
        visit_{snake_name}([[maybe_unused]] {type_name}* node, [[maybe_unused]] Arguments... args) {{
            {base_call}
        }}""")

    def base_call(parent_item):
        if parent_item is not None:
            return f"derived().visit_{parent_item.type.snake_name}(node, args...);"
        else:
            return ""

    functions = [
        function_template.format(
            type_name=item.type.name,
            snake_name=item.type.snake_name,
            base_call=base_call(item.parent)
        ) for item in walk_tree(root)
    ]

    return dedent(template).format(functions="\n\n".join(functions))


def visit_impl(root):
    # TODO: Move over the visitor to NotNull<T> as well.
    template = """\
        template<typename T, typename Visitor, typename... Arguments>
        decltype(auto) visit(NotNull<T*> node, Visitor&& visitor, Arguments&&... args) {{
            const NodeType type = node->type();
            switch (type) {{

        # define TIRO_VISIT_CASE(CaseType, case_function)\\
            case NodeType::CaseType: {{\\
                if constexpr (std::is_base_of_v<T, CaseType>) {{\\
                     return visitor.case_function(\\
                        must_cast<CaseType>(node.get()),\\
                        std::forward<Arguments>(args)...\\
                    );\\
                }}\\
                break;\\
            }}

        {cases}

        # undef TIRO_VISIT_CASE

            }}
        TIRO_UNREACHABLE(\"Broken node type information.\");
        }}"""

    cases = list(
        f"TIRO_VISIT_CASE({item.type.name}, visit_{item.type.snake_name})"
        for item in walk_leaves(root))

    return dedent(template).format(cases=indent("\n".join(cases), 1))


def downcast_impl(root):
    template = """\
        template<typename T, typename Callback>
        decltype(auto) downcast(NotNull<T*> node, Callback&& callback) {{
            const NodeType type = node->type();
            switch (type) {{

        # define TIRO_VISIT_CASE(CaseType)\\
            case NodeType::CaseType: {{\\
                if constexpr (std::is_base_of_v<T, CaseType>) {{\\
                     return callback(must_cast<CaseType>(node.get()));\\
                }}\\
                break;\\
            }}

        {cases}

        # undef TIRO_VISIT_CASE

            }}
        TIRO_UNREACHABLE(\"Broken node type information.\");
        }}"""

    cases = list(
        f"TIRO_VISIT_CASE({item.type.name})"
        for item in walk_leaves(root))

    return dedent(template).format(cases=indent("\n".join(cases), 1))


def constructor_members(item):
    for member in item.type.members:
        if isinstance(member, DataMember) and member.in_constructor:
            yield member


def parent_constructor_members(item):
    parent = item.parent
    if parent:
        yield from parent_constructor_members(parent)
        yield from constructor_members(parent)


def indent(text, level):
    return text_indent(text, "    " * level)


def prefix():
    script = sys.argv[0]
    time = datetime.datetime.now()
    return (f"// Automatically generated by {script} at {time}.\n"
            f"// Do not include this file directly and do not edit by hand!")


if __name__ == "__main__":
    main()
