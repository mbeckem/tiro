## Definition of an tagged union's tag type.
{% macro _type_tag_definition(tag) -%}
{{- tag.doc | as_doc -}}
enum class {{ tag.name }} : {{tag.underlying_type}} {
{% for member in tag.union.members %}
    {{member.name}},
{% endfor %}
};

std::string_view to_string({{tag.name}} type);
{%- endmacro %}

## Implementation of a tagged union's tag type.
{% macro _type_tag_implementation(tag) -%}
std::string_view to_string({{tag.name}} type) {
    switch (type) {
    {% for member in tag.union.members %}
        case {{tag.name}}::{{member.name}}:
            return "{{member.name}}";
    {% endfor %}
    }
    TIRO_UNREACHABLE("Invalid {{tag.name}}.");
}
{%- endmacro %}

## Definition of a tagged union's member type.
{% macro _union_member_definition(member) -%}
{%- if member.kind == "struct" -%}
    {{- member.doc | as_doc }}
    struct {{ member.name }} final {
        {% for struct_member in member.members -%}
        {%- if struct_member.doc -%}
        {{struct_member.doc | as_doc }}
        {% endif %}
        {{ struct_member.type}} {{ struct_member.name }};
        {{- "\n" if not loop.last }}
        {% endfor %}

        {% if member.members | length > 0 -%}
        {{ "explicit" if member.members | length == 1 }} {{ member.name}}(
            {%- for struct_member in member.members -%}
            const {{ struct_member.type }}& {{struct_member.name}}_
            {{- ", " if not loop.last }}
            {%- endfor -%}
        )
        {% for struct_member in member.members %}
            {{ ": " if loop.first else ", " -}}
            {{ struct_member.name}}({{struct_member.name}}_)
        {% endfor %}
        {}
        {% endif %}
    };
{%- elif member.kind == "alias" -%}
    using {{ member.name }} = {{ member.target }};
{%- endif %}
{%- endmacro %}

## Declaration of a tagged union's constructor for a certain member type.
{% macro _union_constructor_declaration(union_type, member) -%}
    {{union_type.name}}(const {{member.name}}& {{member.argument_name}});
{%- endmacro %}

## Implementation of a tagged union's constructor for a certain member type.
{% macro _union_constructor_implementation(union_type, member) -%}
{{union_type.name}}::{{union_type.name}}(const {{member.name}}& {{member.argument_name}})
    : type_({{union_type.tag.name}}::{{member.name}})
    , {{member.field_name}}({{member.argument_name}}) {}
{%- endmacro %}

## Declaration of a tagged union's accessor function.
{% macro _union_accessor_declaration(union_type, member) -%}
    const {{member.name}}& {{member.accessor_name}}() const;
{%- endmacro %}

## Implementation of a tagged union's accessor function.
{% macro _union_accessor_implementation(union_type, member) -%}
const {{union_type.name}}::{{member.name}}& {{union_type.name}}::{{member.accessor_name}}() const {
    TIRO_ASSERT(type_ == {{union_type.tag.name}}::{{member.name}}, "Bad member access on {{union_type.name}}: not a {{member.name}}.");    
    return {{member.field_name}};
}
{%- endmacro %}

## Class body definition of a tagged union type.
{% macro _union_type_definition(union_type) -%}
{{ union_type.doc | as_doc }}
class {{union_type.name}} final {
public:
    {% for member in union_type.members %}
    {{ _union_member_definition(member) }}
    {{- "\n" if not loop.last }}
    {% endfor %}

    {% for member in union_type.members %}
    {{ _union_constructor_declaration(union_type, member) }}
    {% endfor %}

    {{ union_type.tag.name }} type() const noexcept { return type_; }

    {% if union_type.format in ["define", "declare"] -%}
    void format(FormatStream& stream) const;
    {% endif %}

    {% for member in union_type.members %}
    {{ _union_accessor_declaration(union_type, member) }}
    {% endfor %}

    template<typename Visitor>
    TIRO_FORCE_INLINE decltype(auto) visit(Visitor&& vis) const { return visit_impl(*this, std::forward<Visitor>(vis)); }

private:
    template<typename Self, typename Visitor>
    static TIRO_FORCE_INLINE decltype(auto) visit_impl(Self&& self, Visitor&& vis);

private:
    {{union_type.tag.name}} type_;
    union {
        {% for member in union_type.members %}
        {{ member.name }} {{member.field_name}};
        {% endfor %}
    };
};
{%- endmacro %}

## Implements the inline functions of a union type.
{% macro _union_inline_definition(union_type) -%}
template<typename Self, typename Visitor>
decltype(auto) {{union_type.name}}::visit_impl(Self&& self, Visitor&& vis) {
    switch (self.type()) {
    {% for member in union_type.members -%}
    case {{union_type.tag.name}}::{{member.name}}:
        return vis.{{member.visit_name}}(self.{{member.field_name}});
    {%- endfor %}
    }
    TIRO_UNREACHABLE("Invalid {{union_type.name}} type.");
}
{%- endmacro %}

## Implements the union type's class.
{% macro _union_type_implementation(union_type) -%}
{% for member in union_type.members %}
{{ _union_constructor_implementation(union_type, member) }}
{{- "\n" if not loop.last }}
{% endfor %}

{% for member in union_type.members %}
{{ _union_accessor_implementation(union_type, member) }}
{{- "\n" if not loop.last }}
{% endfor %}

{% if union_type.format == "define" -%}
void {{union_type.name}}::format(FormatStream& stream) const {
    struct Formatter {
        FormatStream& stream;

        {% for member in union_type.members -%}
        void {{member.visit_name}}([[maybe_unused]] const {{member.name}}& {{member.argument_name}}) {
            {% if member.kind == "struct" -%}
                {%- set fields = member.members -%}
                {% if fields | length == 0 -%}
                    stream.format("{{member.name}}");
                {% else -%}
                    stream.format("{{member.name}}(
                        {%- for field in fields -%}
                            {{field.name}}: {}
                            {{-", " if not loop.last}}
                        {%- endfor -%}
                    )", 
                        {%- for field in fields -%}
                            {{member.argument_name}}.{{field.name}}
                            {{-", " if not loop.last}}
                        {%- endfor -%}
                    );
                {%- endif %}
            {%- elif member.kind == union -%}
                stream.format("{}", {{member.argument_name}});
            {%- endif %}
        }
        {{"\n" if not loop.last }}
        {%- endfor %}
    };

    Formatter formatter{stream};
    visit(formatter);
}
{%- endif %}
{%- endmacro %}

## Forward declaration of a type.
{% macro declare_type(type) -%}
{%- if type.kind == "union" -%}
class {{type.name}};
{%- elif type.kind == "tag" -%}
enum class {{type.name}} : {{type.underlying_type}};
{%- endif -%}
{%- endmacro %}

## Define the type (class definitions etc.)
{% macro define_type(type) -%}
{%- if type.kind == "union" -%}
{{ _union_type_definition(type) }}
{%- elif type.kind == "tag" -%}
{{ _type_tag_definition(type) }}
{%- endif -%}
{%- endmacro %}


## Implement inline functions for that type.
{% macro define_inline(type) -%}
{%- if type.kind == "union" -%}
    {{- _union_inline_definition(type) -}}
{% endif %}
{%- endmacro %}

## Implement the type.
{% macro implement_type(type) -%}
{%- if type.kind == "union" -%}
{{ _union_type_implementation(type) }}
{%- elif type.kind == "tag" -%}
{{ _type_tag_implementation(type) }}
{%- endif -%}
{%- endmacro %}
