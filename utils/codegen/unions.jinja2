## Definition of a tagged union's tag type.
{% macro _type_tag_definition(tag) -%}
{{- tag.doc | as_doc -}}
enum class {{ tag.name }} : {{tag.underlying_type}} {
{% for member in tag.union.members %}
    {%- if tag.union.doc_mode == "tag" -%}
    {{- "\n" if not loop.first and member.doc }}
    {{- member.doc | as_doc -}}
    {%- endif -%}
    {{member.name}} {%- if loop.first and tag.start_value != None %} = {{tag.start_value}}{%- endif -%},
{% endfor %}
};

std::string_view to_string({{tag.name}} type);
{%- endmacro %}

## Implementation of a tagged union's tag type.
{% macro _type_tag_implementation(tag) -%}
std::string_view to_string({{tag.name}} type) {
    switch (type) {
    {% for member in tag.union.members %}
        case {{tag.name}}::{{member.name}}:
            return "{{member.name}}";
    {% endfor %}
    }
    TIRO_UNREACHABLE("Invalid {{tag.name}}.");
}
{%- endmacro %}

## Definition of a tagged union's member type.
{% macro _union_member_definition(union_type, member) -%}
    {% if union_type.doc_mode == "member" %}{{- member.doc | as_doc -}}{% endif %}
{% if member.kind == "struct" -%}
    struct {{ member.name }} final {
        {% for struct_member in member.members -%}
        {{struct_member.doc | as_doc -}}
        {{ struct_member.type}} {{ struct_member.name }};
        {{- "\n" if not loop.last and loop.nextitem.doc }}
        {% endfor %}

        {% if member.members | length > 0 -%}
        {{ "explicit" if member.members | length == 1 }} {{ member.name}}(
            {%- for struct_member in member.members -%}
            const {{ struct_member.type }}& {{struct_member.name}}_
            {{- ", " if not loop.last }}
            {%- endfor -%}
        )
        {% for struct_member in member.members %}
            {{ ": " if loop.first else ", " -}}
            {{ struct_member.name}}({{struct_member.name}}_)
        {% endfor %}
        {}
        {% endif %}
    };
{%- elif member.kind == "alias" -%}
    using {{ member.name }} = {{ member.target }};
{%- endif %}
{%- endmacro %}

## Declaration of a tagged union's static factory member function.
{% macro _union_static_factory_declaration(union_type, member) -%}
    static {{union_type.name}} {{member.factory_name}}(
        {%- if member.kind == "struct" %}
            {%- for struct_member in member.members -%}
            const {{ struct_member.type }}& {{struct_member.name}}
            {{- ", " if not loop.last }}
            {%- endfor -%}
        {%- elif member.kind == "alias" -%}
            const {{ member.name }}& {{member.argument_name}}
        {%- endif -%}
    );
{%- endmacro %}

## Definition of a tagged union's static factory member function.
{% macro _union_static_factory_implementation(union_type, member) -%}
    {{union_type.name}} {{union_type.name}}::{{member.factory_name}}(
        {%- if member.kind == "struct" %}
            {%- for struct_member in member.members -%}
            const {{struct_member.type}}& {{struct_member.name}}
            {{- ", " if not loop.last }}
            {%- endfor -%}
        {%- elif member.kind == "alias" -%}
            const {{ member.name }}& {{member.argument_name}}
        {%- endif -%}
    ) {
    {% if member.kind == "struct" %}
    return {{member.name}}{
        {%- for struct_member in member.members -%}
        {{struct_member.name}}
        {{- ", " if not loop.last }}
        {%- endfor -%}
    };
    {% elif member.kind == "alias" %}
    return {{member.argument_name}};
    {% endif %}
}
{%- endmacro %}

## Declaration of a tagged union's constructor for a certain member type.
{% macro _union_constructor_declaration(union_type, member) -%}
    {{union_type.name}}(const {{member.name}}& {{member.argument_name}});
{%- endmacro %}

## Implementation of a tagged union's constructor for a certain member type.
{% macro _union_constructor_implementation(union_type, member) -%}
{{union_type.name}}::{{union_type.name}}(const {{member.name}}& {{member.argument_name}})
    : type_({{union_type.tag.name}}::{{member.name}})
    , {{member.field_name}}({{member.argument_name}}) {}
{%- endmacro %}

## Declaration of a tagged union's accessor function.
{% macro _union_accessor_declaration(union_type, member) -%}
    const {{member.name}}& {{member.accessor_name}}() const;
{%- endmacro %}

## Implementation of a tagged union's accessor function.
{% macro _union_accessor_implementation(union_type, member) -%}
const {{union_type.name}}::{{member.name}}& {{union_type.name}}::{{member.accessor_name}}() const {
    TIRO_ASSERT(type_ == {{union_type.tag.name}}::{{member.name}}, "Bad member access on {{union_type.name}}: not a {{member.name}}.");
    return {{member.field_name}};
}
{%- endmacro %}

## Class body definition of a tagged union type.
{% macro _union_type_definition(union_type) -%}
{{ union_type.doc | as_doc -}}
class {{union_type.name}} final {
public:
    {% for member in union_type.members %}
    {{ _union_member_definition(union_type, member) }}
    {{- "\n" if not loop.last }}
    {% endfor %}

    {% for member in union_type.members %}
    {{ _union_static_factory_declaration(union_type, member) }}
    {% endfor %}

    {% for member in union_type.members %}
    {{ _union_constructor_declaration(union_type, member) }}
    {% endfor %}

    {{ union_type.tag.name }} type() const noexcept { return type_; }

    {% if union_type.format in ["define", "declare"] -%}
    void format(FormatStream& stream) const;
    {% endif %}

    {% if union_type.hash in ["define", "declare"] -%}
    void build_hash(Hasher& h) const;
    {% endif %}

    {% for member in union_type.members %}
    {{ _union_accessor_declaration(union_type, member) }}
    {% endfor %}

    template<typename Visitor, typename... Args>
    TIRO_FORCE_INLINE decltype(auto) visit(Visitor&& vis, Args&&... args) { 
        return visit_impl(*this, std::forward<Visitor>(vis), std::forward<Args>(args)...);
    }

    template<typename Visitor, typename... Args>
    TIRO_FORCE_INLINE decltype(auto) visit(Visitor&& vis, Args&&... args) const { 
        return visit_impl(*this, std::forward<Visitor>(vis), std::forward<Args>(args)...);
    }

private:
    template<typename Self, typename Visitor, typename... Args>
    static TIRO_FORCE_INLINE decltype(auto) visit_impl(Self&& self, Visitor&& vis, Args&&... args);

private:
    {{union_type.tag.name}} type_;
    union {
        {% for member in union_type.members %}
        {{ member.name }} {{member.field_name}};
        {% endfor %}
    };
};
{%- if union_type.equality == "define" %}


bool operator==(const {{union_type.name}}& lhs, const {{union_type.name}}& rhs);
bool operator!=(const {{union_type.name}}& lhs, const {{union_type.name}}& rhs);
{%- endif -%}
{%- endmacro %}

## Implements the inline functions of a union type.
{% macro _union_inline_definition(union_type) -%}
template<typename Self, typename Visitor, typename... Args>
decltype(auto) {{union_type.name}}::visit_impl(Self&& self, Visitor&& vis, Args&&... args) {
    switch (self.type()) {
    {% for member in union_type.members -%}
    case {{union_type.tag.name}}::{{member.name}}:
        return vis.{{member.visit_name}}(self.{{member.field_name}}, std::forward<Args>(args)...);
    {%- endfor %}
    }
    TIRO_UNREACHABLE("Invalid {{union_type.name}} type.");
}
{%- endmacro %}

## Implements the union type's class.
{% macro _union_type_implementation(union_type) -%}
{% for member in union_type.members %}
{{ _union_static_factory_implementation(union_type, member) }}
{{- "\n" if not loop.last }}
{% endfor %}

{% for member in union_type.members %}
{{ _union_constructor_implementation(union_type, member) }}
{{- "\n" if not loop.last }}
{% endfor %}

{% for member in union_type.members %}
{{ _union_accessor_implementation(union_type, member) }}
{{- "\n" if not loop.last }}
{% endfor -%}
{%- if union_type.format == "define" %}

void {{union_type.name}}::format(FormatStream& stream) const {
    struct FormatVisitor {
        FormatStream& stream;

        {% for member in union_type.members %}
        void {{member.visit_name}}([[maybe_unused]] const {{member.name}}& {{member.argument_name}}) {
        {% if member.kind == "struct" %}
            {%- set fields = member.members -%}
            {% if fields | length == 0 %}
            stream.format("{{member.name}}");
            {% else %}
            stream.format("{{member.name}}(
                {%- for field in fields -%}
                    {{field.name}}: {}
                    {{-", " if not loop.last}}
                {%- endfor -%}
            )"
                {%- for field in fields -%}
                    {{", " -}}
                    {{member.argument_name}}.{{field.name}}
                {%- endfor -%}
            );
            {% endif %}
        {% elif member.kind == "alias" %}
            stream.format("{}", {{member.argument_name}});
        {% endif %}
        }
        {{- "\n" if not loop.last }}
        {% endfor %}
    };
    visit(FormatVisitor{stream});
}
{%- endif %}
{% if union_type.hash == "define" %}


void {{union_type.name}}::build_hash(Hasher& h) const {
    h.append(type());

    struct HashVisitor {
        Hasher& h;

        {% for member in union_type.members %}
        void {{member.visit_name}}([[maybe_unused]] const {{member.name}}& {{member.argument_name}}) {
        {% if member.kind == "struct" %}
            {%- set fields = member.members -%}
            {% if fields | length == 0 %}
            return;
            {% else %}
            h
            {%- for field in fields -%}
                .append({{member.argument_name}}.{{field.name}})
            {%- endfor -%}
            ;
            {% endif %}
        {% elif member.kind == "alias" %}
            h.append({{member.argument_name}});
        {% endif %}
        }
        {{- "\n" if not loop.last }}
        {% endfor %}
    };
    return visit(HashVisitor{h});
}
{%- endif %}
{% if union_type.equality == "define" %}


bool operator==(const {{union_type.name}}& lhs, const {{union_type.name}}& rhs) {
    if (lhs.type() != rhs.type())
        return false;

    struct EqualityVisitor {
        const {{union_type.name}}& rhs;

        {% for member in union_type.members %}
        bool {{member.visit_name}}([[maybe_unused]] const {{union_type.name}}::{{member.name}}& {{member.argument_name}}) {
            [[maybe_unused]] const auto& other = rhs.{{member.accessor_name}}();
        {% if member.kind == "struct" %}
            {%- set fields = member.members -%}
            {% if fields | length == 0 %}
            return true;
            {% else %}
            {{"return "}}
            {%- for field in fields -%}
                {{member.argument_name}}.{{field.name}} == other.{{field.name}}
                {{-" && " if not loop.last}}
            {%- endfor -%}
            ;
            {% endif %}
        {% elif member.kind == "alias" %}
            return {{member.argument_name}} == other;
        {% endif %}
        }
        {{- "\n" if not loop.last }}
        {% endfor %}
    };
    return lhs.visit(EqualityVisitor{rhs});
}

bool operator!=(const {{union_type.name}}& lhs, const {{union_type.name}}& rhs) {
    return !(lhs == rhs);
}
{%- endif -%}
{%- endmacro -%}

## Forward declaration of a type.
{% macro declare_type(type) -%}
{%- if type.kind == "union" -%}
class {{type.name}};
{%- elif type.kind == "tag" -%}
enum class {{type.name}} : {{type.underlying_type}};
{%- endif -%}
{%- endmacro %}

## Define the type (class definitions etc.)
{% macro define_type(type) -%}
{%- if type.kind == "union" -%}
{{ _union_type_definition(type) }}
{%- elif type.kind == "tag" -%}
{{ _type_tag_definition(type) }}
{%- endif -%}
{%- endmacro %}


## Implement inline functions for that type.
{% macro define_inline(type) -%}
{%- if type.kind == "union" -%}
    {{- _union_inline_definition(type) -}}
{%- endif -%}
{%- endmacro %}

## Implement the type.
{% macro implement_type(type) -%}
{%- if type.kind == "union" -%}
{{ _union_type_implementation(type) }}
{%- elif type.kind == "tag" -%}
{{ _type_tag_implementation(type) }}
{%- endif -%}
{%- endmacro %}
