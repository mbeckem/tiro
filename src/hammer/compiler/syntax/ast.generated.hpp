// Automatically generated by ./utils/generate-ast at 2020-01-04 16:19:09.128395.
// Do not include this file directly and do not edit by hand!

namespace hammer::compiler {

class ArrayLiteral;
class AssertStmt;
class BinaryExpr;
class BlockExpr;
class BooleanLiteral;
class BreakExpr;
class CallExpr;
class ContinueExpr;
class Decl;
class DeclStmt;
class DotExpr;
class EmptyStmt;
class Expr;
class ExprList;
class ExprStmt;
class File;
class FloatLiteral;
class ForStmt;
class FuncDecl;
class FuncLiteral;
class IfExpr;
class ImportDecl;
class IndexExpr;
class IntegerLiteral;
class Literal;
class MapEntry;
class MapEntryList;
class MapLiteral;
class Node;
class NodeList;
class NullLiteral;
class ParamDecl;
class ParamList;
class ReturnExpr;
class Root;
class SetLiteral;
class Stmt;
class StmtList;
class StringLiteral;
class StringSequenceExpr;
class SymbolLiteral;
class TupleLiteral;
class UnaryExpr;
class VarDecl;
class VarExpr;
class WhileStmt;

enum class NodeType : int {
    FirstNode = 1,
    FirstDecl = 1,
    FuncDecl = 1,
    ImportDecl = 2,
    ParamDecl = 3,
    VarDecl = 4,
    LastDecl = 4,
    FirstExpr = 5,
    BinaryExpr = 5,
    BlockExpr = 6,
    BreakExpr = 7,
    CallExpr = 8,
    ContinueExpr = 9,
    DotExpr = 10,
    IfExpr = 11,
    IndexExpr = 12,
    FirstLiteral = 13,
    ArrayLiteral = 13,
    BooleanLiteral = 14,
    FloatLiteral = 15,
    FuncLiteral = 16,
    IntegerLiteral = 17,
    MapLiteral = 18,
    NullLiteral = 19,
    SetLiteral = 20,
    StringLiteral = 21,
    SymbolLiteral = 22,
    TupleLiteral = 23,
    LastLiteral = 23,
    ReturnExpr = 24,
    StringSequenceExpr = 25,
    UnaryExpr = 26,
    VarExpr = 27,
    LastExpr = 27,
    ExprList = 28,
    File = 29,
    MapEntry = 30,
    MapEntryList = 31,
    NodeList = 32,
    ParamList = 33,
    Root = 34,
    FirstStmt = 35,
    AssertStmt = 35,
    DeclStmt = 36,
    EmptyStmt = 37,
    ExprStmt = 38,
    ForStmt = 39,
    WhileStmt = 40,
    LastStmt = 40,
    StmtList = 41,
    LastNode = 41
};

class Decl : public Node {
protected:
    explicit Decl(NodeType child_type);

public:
    ~Decl();

    // invalid if anonymous
    void name(const InternedString& value);
    const InternedString& name() const;

    void declared_symbol(SymbolEntryPtr value);
    SymbolEntryPtr declared_symbol() const;

private:
    InternedString name_;
    WeakSymbolEntryPtr declared_symbol_;
};

class FuncDecl final : public Decl {
public:
    explicit FuncDecl();
    ~FuncDecl();

    void params(const NodePtr<ParamList>& value);
    const NodePtr<ParamList>& params() const;

    void body(const NodePtr<Expr>& value);
    const NodePtr<Expr>& body() const;

    void param_scope(ScopePtr value);
    ScopePtr param_scope() const;

    void body_scope(ScopePtr value);
    ScopePtr body_scope() const;

private:
    NodePtr<ParamList> params_;
    NodePtr<Expr> body_;
    WeakScopePtr param_scope_;
    WeakScopePtr body_scope_;
};

class ImportDecl final : public Decl {
public:
    explicit ImportDecl();
    ~ImportDecl();

    std::vector<InternedString>& path_elements() { return path_elements_; }

private:
    std::vector<InternedString> path_elements_;
};

class ParamDecl final : public Decl {
public:
    explicit ParamDecl();
    ~ParamDecl();

private:
};

class VarDecl final : public Decl {
public:
    explicit VarDecl();
    ~VarDecl();

    void initializer(const NodePtr<Expr>& value);
    const NodePtr<Expr>& initializer() const;

    void is_const(const bool& value);
    const bool& is_const() const;

private:
    NodePtr<Expr> initializer_;
    bool is_const_;
};

class Expr : public Node {
protected:
    explicit Expr(NodeType child_type);

public:
    ~Expr();

    void expr_type(const ExprType& value);
    const ExprType& expr_type() const;

private:
    ExprType expr_type_;
};

class BinaryExpr final : public Expr {
public:
    explicit BinaryExpr(BinaryOperator operation);
    ~BinaryExpr();

    void operation(const BinaryOperator& value);
    const BinaryOperator& operation() const;

    void left(const NodePtr<Expr>& value);
    const NodePtr<Expr>& left() const;

    void right(const NodePtr<Expr>& value);
    const NodePtr<Expr>& right() const;

private:
    BinaryOperator operation_;
    NodePtr<Expr> left_;
    NodePtr<Expr> right_;
};

class BlockExpr final : public Expr {
public:
    explicit BlockExpr();
    ~BlockExpr();

    void stmts(const NodePtr<StmtList>& value);
    const NodePtr<StmtList>& stmts() const;

    void block_scope(ScopePtr value);
    ScopePtr block_scope() const;

private:
    NodePtr<StmtList> stmts_;
    WeakScopePtr block_scope_;
};

class BreakExpr final : public Expr {
public:
    explicit BreakExpr();
    ~BreakExpr();

private:
};

class CallExpr final : public Expr {
public:
    explicit CallExpr();
    ~CallExpr();

    void func(const NodePtr<Expr>& value);
    const NodePtr<Expr>& func() const;

    void args(const NodePtr<ExprList>& value);
    const NodePtr<ExprList>& args() const;

private:
    NodePtr<Expr> func_;
    NodePtr<ExprList> args_;
};

class ContinueExpr final : public Expr {
public:
    explicit ContinueExpr();
    ~ContinueExpr();

private:
};

class DotExpr final : public Expr {
public:
    explicit DotExpr();
    ~DotExpr();

    void inner(const NodePtr<Expr>& value);
    const NodePtr<Expr>& inner() const;

    void name(const InternedString& value);
    const InternedString& name() const;

private:
    NodePtr<Expr> inner_;
    InternedString name_;
};

class IfExpr final : public Expr {
public:
    explicit IfExpr();
    ~IfExpr();

    void condition(const NodePtr<Expr>& value);
    const NodePtr<Expr>& condition() const;

    void then_branch(const NodePtr<Expr>& value);
    const NodePtr<Expr>& then_branch() const;

    void else_branch(const NodePtr<Expr>& value);
    const NodePtr<Expr>& else_branch() const;

private:
    NodePtr<Expr> condition_;
    NodePtr<Expr> then_branch_;
    NodePtr<Expr> else_branch_;
};

class IndexExpr final : public Expr {
public:
    explicit IndexExpr();
    ~IndexExpr();

    void inner(const NodePtr<Expr>& value);
    const NodePtr<Expr>& inner() const;

    void index(const NodePtr<Expr>& value);
    const NodePtr<Expr>& index() const;

private:
    NodePtr<Expr> inner_;
    NodePtr<Expr> index_;
};

class Literal : public Expr {
protected:
    explicit Literal(NodeType child_type);

public:
    ~Literal();

private:
};

class ArrayLiteral final : public Literal {
public:
    explicit ArrayLiteral();
    ~ArrayLiteral();

    void entries(const NodePtr<ExprList>& value);
    const NodePtr<ExprList>& entries() const;

private:
    NodePtr<ExprList> entries_;
};

class BooleanLiteral final : public Literal {
public:
    explicit BooleanLiteral(bool value);
    ~BooleanLiteral();

    void value(const bool& value);
    const bool& value() const;

private:
    bool value_;
};

class FloatLiteral final : public Literal {
public:
    explicit FloatLiteral(f64 value);
    ~FloatLiteral();

    void value(const f64& value);
    const f64& value() const;

private:
    f64 value_;
};

class FuncLiteral final : public Literal {
public:
    explicit FuncLiteral();
    ~FuncLiteral();

    void func(const NodePtr<FuncDecl>& value);
    const NodePtr<FuncDecl>& func() const;

private:
    NodePtr<FuncDecl> func_;
};

class IntegerLiteral final : public Literal {
public:
    explicit IntegerLiteral(i64 value);
    ~IntegerLiteral();

    void value(const i64& value);
    const i64& value() const;

private:
    i64 value_;
};

class MapLiteral final : public Literal {
public:
    explicit MapLiteral();
    ~MapLiteral();

    void entries(const NodePtr<MapEntryList>& value);
    const NodePtr<MapEntryList>& entries() const;

private:
    NodePtr<MapEntryList> entries_;
};

class NullLiteral final : public Literal {
public:
    explicit NullLiteral();
    ~NullLiteral();

private:
};

class SetLiteral final : public Literal {
public:
    explicit SetLiteral();
    ~SetLiteral();

    void entries(const NodePtr<ExprList>& value);
    const NodePtr<ExprList>& entries() const;

private:
    NodePtr<ExprList> entries_;
};

class StringLiteral final : public Literal {
public:
    explicit StringLiteral(InternedString value);
    ~StringLiteral();

    void value(const InternedString& value);
    const InternedString& value() const;

private:
    InternedString value_;
};

class SymbolLiteral final : public Literal {
public:
    explicit SymbolLiteral(InternedString value);
    ~SymbolLiteral();

    void value(const InternedString& value);
    const InternedString& value() const;

private:
    InternedString value_;
};

class TupleLiteral final : public Literal {
public:
    explicit TupleLiteral();
    ~TupleLiteral();

    void entries(const NodePtr<ExprList>& value);
    const NodePtr<ExprList>& entries() const;

private:
    NodePtr<ExprList> entries_;
};

class ReturnExpr final : public Expr {
public:
    explicit ReturnExpr();
    ~ReturnExpr();

    void inner(const NodePtr<Expr>& value);
    const NodePtr<Expr>& inner() const;

private:
    NodePtr<Expr> inner_;
};

class StringSequenceExpr final : public Expr {
public:
    explicit StringSequenceExpr();
    ~StringSequenceExpr();

    void strings(const NodePtr<ExprList>& value);
    const NodePtr<ExprList>& strings() const;

private:
    NodePtr<ExprList> strings_;
};

class UnaryExpr final : public Expr {
public:
    explicit UnaryExpr(UnaryOperator operation);
    ~UnaryExpr();

    void operation(const UnaryOperator& value);
    const UnaryOperator& operation() const;

    void inner(const NodePtr<Expr>& value);
    const NodePtr<Expr>& inner() const;

private:
    UnaryOperator operation_;
    NodePtr<Expr> inner_;
};

class VarExpr final : public Expr {
public:
    explicit VarExpr(InternedString name);
    ~VarExpr();

    void name(const InternedString& value);
    const InternedString& name() const;

    void surrounding_scope(ScopePtr value);
    ScopePtr surrounding_scope() const;

    void resolved_symbol(SymbolEntryPtr value);
    SymbolEntryPtr resolved_symbol() const;

private:
    InternedString name_;
    WeakScopePtr surrounding_scope_;
    WeakSymbolEntryPtr resolved_symbol_;
};

class ExprList final : public Node, public NodeListBase<Expr> {
public:
    explicit ExprList();
    ~ExprList();

private:
};

class File final : public Node {
public:
    explicit File();
    ~File();

    void file_name(const InternedString& value);
    const InternedString& file_name() const;

    // items at top level
    void items(const NodePtr<NodeList>& value);
    const NodePtr<NodeList>& items() const;

    void file_scope(ScopePtr value);
    ScopePtr file_scope() const;

private:
    InternedString file_name_;
    NodePtr<NodeList> items_;
    WeakScopePtr file_scope_;
};

class MapEntry final : public Node {
public:
    explicit MapEntry();
    ~MapEntry();

    void key(const NodePtr<Expr>& value);
    const NodePtr<Expr>& key() const;

    void value(const NodePtr<Expr>& value);
    const NodePtr<Expr>& value() const;

private:
    NodePtr<Expr> key_;
    NodePtr<Expr> value_;
};

class MapEntryList final : public Node, public NodeListBase<MapEntry> {
public:
    explicit MapEntryList();
    ~MapEntryList();

private:
};

class NodeList final : public Node, public NodeListBase<Node> {
public:
    explicit NodeList();
    ~NodeList();

private:
};

class ParamList final : public Node, public NodeListBase<ParamDecl> {
public:
    explicit ParamList();
    ~ParamList();

private:
};

class Root final : public Node {
public:
    explicit Root();
    ~Root();

    void file(const NodePtr<File>& value);
    const NodePtr<File>& file() const;

    void root_scope(ScopePtr value);
    ScopePtr root_scope() const;

private:
    NodePtr<File> file_;
    WeakScopePtr root_scope_;
};

class Stmt : public Node {
protected:
    explicit Stmt(NodeType child_type);

public:
    ~Stmt();

private:
};

class AssertStmt final : public Stmt {
public:
    explicit AssertStmt();
    ~AssertStmt();

    void condition(const NodePtr<Expr>& value);
    const NodePtr<Expr>& condition() const;

    // optional
    void message(const NodePtr<StringLiteral>& value);
    const NodePtr<StringLiteral>& message() const;

private:
    NodePtr<Expr> condition_;
    NodePtr<StringLiteral> message_;
};

class DeclStmt final : public Stmt {
public:
    explicit DeclStmt();
    ~DeclStmt();

    void decl(const NodePtr<VarDecl>& value);
    const NodePtr<VarDecl>& decl() const;

private:
    NodePtr<VarDecl> decl_;
};

class EmptyStmt final : public Stmt {
public:
    explicit EmptyStmt();
    ~EmptyStmt();

private:
};

class ExprStmt final : public Stmt {
public:
    explicit ExprStmt();
    ~ExprStmt();

    void expr(const NodePtr<Expr>& value);
    const NodePtr<Expr>& expr() const;

private:
    NodePtr<Expr> expr_;
};

class ForStmt final : public Stmt {
public:
    explicit ForStmt();
    ~ForStmt();

    // optional
    void decl(const NodePtr<DeclStmt>& value);
    const NodePtr<DeclStmt>& decl() const;

    // optional
    void condition(const NodePtr<Expr>& value);
    const NodePtr<Expr>& condition() const;

    // optional
    void step(const NodePtr<Expr>& value);
    const NodePtr<Expr>& step() const;

    void body(const NodePtr<Expr>& value);
    const NodePtr<Expr>& body() const;

    void decl_scope(ScopePtr value);
    ScopePtr decl_scope() const;

    void body_scope(ScopePtr value);
    ScopePtr body_scope() const;

private:
    NodePtr<DeclStmt> decl_;
    NodePtr<Expr> condition_;
    NodePtr<Expr> step_;
    NodePtr<Expr> body_;
    WeakScopePtr decl_scope_;
    WeakScopePtr body_scope_;
};

class WhileStmt final : public Stmt {
public:
    explicit WhileStmt();
    ~WhileStmt();

    void condition(const NodePtr<Expr>& value);
    const NodePtr<Expr>& condition() const;

    void body(const NodePtr<BlockExpr>& value);
    const NodePtr<BlockExpr>& body() const;

    void body_scope(ScopePtr value);
    ScopePtr body_scope() const;

private:
    NodePtr<Expr> condition_;
    NodePtr<BlockExpr> body_;
    WeakScopePtr body_scope_;
};

class StmtList final : public Node, public NodeListBase<Stmt> {
public:
    explicit StmtList();
    ~StmtList();

private:
};

template<typename Derived, typename... Arguments>
class DefaultNodeVisitor {
public:
    DefaultNodeVisitor() = default;

    HAMMER_VISITOR_DECL ~DefaultNodeVisitor() = default;

    HAMMER_VISITOR_DECL void
    visit_node([[maybe_unused]] const NodePtr<Node>& node,
        [[maybe_unused]] Arguments... args) {}

    HAMMER_VISITOR_DECL void
    visit_decl([[maybe_unused]] const NodePtr<Decl>& node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_node(node, args...);
    }

    HAMMER_VISITOR_DECL void
    visit_func_decl([[maybe_unused]] const NodePtr<FuncDecl>& node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_decl(node, args...);
    }

    HAMMER_VISITOR_DECL void
    visit_import_decl([[maybe_unused]] const NodePtr<ImportDecl>& node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_decl(node, args...);
    }

    HAMMER_VISITOR_DECL void
    visit_param_decl([[maybe_unused]] const NodePtr<ParamDecl>& node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_decl(node, args...);
    }

    HAMMER_VISITOR_DECL void
    visit_var_decl([[maybe_unused]] const NodePtr<VarDecl>& node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_decl(node, args...);
    }

    HAMMER_VISITOR_DECL void
    visit_expr([[maybe_unused]] const NodePtr<Expr>& node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_node(node, args...);
    }

    HAMMER_VISITOR_DECL void
    visit_binary_expr([[maybe_unused]] const NodePtr<BinaryExpr>& node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_expr(node, args...);
    }

    HAMMER_VISITOR_DECL void
    visit_block_expr([[maybe_unused]] const NodePtr<BlockExpr>& node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_expr(node, args...);
    }

    HAMMER_VISITOR_DECL void
    visit_break_expr([[maybe_unused]] const NodePtr<BreakExpr>& node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_expr(node, args...);
    }

    HAMMER_VISITOR_DECL void
    visit_call_expr([[maybe_unused]] const NodePtr<CallExpr>& node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_expr(node, args...);
    }

    HAMMER_VISITOR_DECL void
    visit_continue_expr([[maybe_unused]] const NodePtr<ContinueExpr>& node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_expr(node, args...);
    }

    HAMMER_VISITOR_DECL void
    visit_dot_expr([[maybe_unused]] const NodePtr<DotExpr>& node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_expr(node, args...);
    }

    HAMMER_VISITOR_DECL void
    visit_if_expr([[maybe_unused]] const NodePtr<IfExpr>& node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_expr(node, args...);
    }

    HAMMER_VISITOR_DECL void
    visit_index_expr([[maybe_unused]] const NodePtr<IndexExpr>& node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_expr(node, args...);
    }

    HAMMER_VISITOR_DECL void
    visit_literal([[maybe_unused]] const NodePtr<Literal>& node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_expr(node, args...);
    }

    HAMMER_VISITOR_DECL void
    visit_array_literal([[maybe_unused]] const NodePtr<ArrayLiteral>& node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_literal(node, args...);
    }

    HAMMER_VISITOR_DECL void
    visit_boolean_literal([[maybe_unused]] const NodePtr<BooleanLiteral>& node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_literal(node, args...);
    }

    HAMMER_VISITOR_DECL void
    visit_float_literal([[maybe_unused]] const NodePtr<FloatLiteral>& node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_literal(node, args...);
    }

    HAMMER_VISITOR_DECL void
    visit_func_literal([[maybe_unused]] const NodePtr<FuncLiteral>& node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_literal(node, args...);
    }

    HAMMER_VISITOR_DECL void
    visit_integer_literal([[maybe_unused]] const NodePtr<IntegerLiteral>& node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_literal(node, args...);
    }

    HAMMER_VISITOR_DECL void
    visit_map_literal([[maybe_unused]] const NodePtr<MapLiteral>& node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_literal(node, args...);
    }

    HAMMER_VISITOR_DECL void
    visit_null_literal([[maybe_unused]] const NodePtr<NullLiteral>& node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_literal(node, args...);
    }

    HAMMER_VISITOR_DECL void
    visit_set_literal([[maybe_unused]] const NodePtr<SetLiteral>& node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_literal(node, args...);
    }

    HAMMER_VISITOR_DECL void
    visit_string_literal([[maybe_unused]] const NodePtr<StringLiteral>& node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_literal(node, args...);
    }

    HAMMER_VISITOR_DECL void
    visit_symbol_literal([[maybe_unused]] const NodePtr<SymbolLiteral>& node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_literal(node, args...);
    }

    HAMMER_VISITOR_DECL void
    visit_tuple_literal([[maybe_unused]] const NodePtr<TupleLiteral>& node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_literal(node, args...);
    }

    HAMMER_VISITOR_DECL void
    visit_return_expr([[maybe_unused]] const NodePtr<ReturnExpr>& node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_expr(node, args...);
    }

    HAMMER_VISITOR_DECL void visit_string_sequence_expr(
        [[maybe_unused]] const NodePtr<StringSequenceExpr>& node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_expr(node, args...);
    }

    HAMMER_VISITOR_DECL void
    visit_unary_expr([[maybe_unused]] const NodePtr<UnaryExpr>& node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_expr(node, args...);
    }

    HAMMER_VISITOR_DECL void
    visit_var_expr([[maybe_unused]] const NodePtr<VarExpr>& node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_expr(node, args...);
    }

    HAMMER_VISITOR_DECL void
    visit_expr_list([[maybe_unused]] const NodePtr<ExprList>& node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_node(node, args...);
    }

    HAMMER_VISITOR_DECL void
    visit_file([[maybe_unused]] const NodePtr<File>& node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_node(node, args...);
    }

    HAMMER_VISITOR_DECL void
    visit_map_entry([[maybe_unused]] const NodePtr<MapEntry>& node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_node(node, args...);
    }

    HAMMER_VISITOR_DECL void
    visit_map_entry_list([[maybe_unused]] const NodePtr<MapEntryList>& node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_node(node, args...);
    }

    HAMMER_VISITOR_DECL void
    visit_node_list([[maybe_unused]] const NodePtr<NodeList>& node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_node(node, args...);
    }

    HAMMER_VISITOR_DECL void
    visit_param_list([[maybe_unused]] const NodePtr<ParamList>& node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_node(node, args...);
    }

    HAMMER_VISITOR_DECL void
    visit_root([[maybe_unused]] const NodePtr<Root>& node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_node(node, args...);
    }

    HAMMER_VISITOR_DECL void
    visit_stmt([[maybe_unused]] const NodePtr<Stmt>& node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_node(node, args...);
    }

    HAMMER_VISITOR_DECL void
    visit_assert_stmt([[maybe_unused]] const NodePtr<AssertStmt>& node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_stmt(node, args...);
    }

    HAMMER_VISITOR_DECL void
    visit_decl_stmt([[maybe_unused]] const NodePtr<DeclStmt>& node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_stmt(node, args...);
    }

    HAMMER_VISITOR_DECL void
    visit_empty_stmt([[maybe_unused]] const NodePtr<EmptyStmt>& node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_stmt(node, args...);
    }

    HAMMER_VISITOR_DECL void
    visit_expr_stmt([[maybe_unused]] const NodePtr<ExprStmt>& node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_stmt(node, args...);
    }

    HAMMER_VISITOR_DECL void
    visit_for_stmt([[maybe_unused]] const NodePtr<ForStmt>& node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_stmt(node, args...);
    }

    HAMMER_VISITOR_DECL void
    visit_while_stmt([[maybe_unused]] const NodePtr<WhileStmt>& node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_stmt(node, args...);
    }

    HAMMER_VISITOR_DECL void
    visit_stmt_list([[maybe_unused]] const NodePtr<StmtList>& node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_node(node, args...);
    }

private:
    Derived& derived() { return static_cast<Derived&>(*this); }
};

} // namespace hammer::compiler
