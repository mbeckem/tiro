// Automatically generated by utils/generate-ast at 2020-01-11 17:24:39.344306.
// Do not include this file directly and do not edit by hand!

#include "hammer/compiler/semantics/symbol_table.hpp" // Ugh :/
#include "hammer/compiler/syntax/ast.hpp"

#include <utility>

namespace hammer::compiler {

std::string_view to_string(NodeType type) {
    switch (type) {
    case NodeType::TupleBinding:
        return "TupleBinding";
    case NodeType::VarBinding:
        return "VarBinding";
    case NodeType::BindingList:
        return "BindingList";
    case NodeType::FuncDecl:
        return "FuncDecl";
    case NodeType::ImportDecl:
        return "ImportDecl";
    case NodeType::ParamDecl:
        return "ParamDecl";
    case NodeType::VarDecl:
        return "VarDecl";
    case NodeType::BinaryExpr:
        return "BinaryExpr";
    case NodeType::BlockExpr:
        return "BlockExpr";
    case NodeType::BreakExpr:
        return "BreakExpr";
    case NodeType::CallExpr:
        return "CallExpr";
    case NodeType::ContinueExpr:
        return "ContinueExpr";
    case NodeType::DotExpr:
        return "DotExpr";
    case NodeType::IfExpr:
        return "IfExpr";
    case NodeType::IndexExpr:
        return "IndexExpr";
    case NodeType::ArrayLiteral:
        return "ArrayLiteral";
    case NodeType::BooleanLiteral:
        return "BooleanLiteral";
    case NodeType::FloatLiteral:
        return "FloatLiteral";
    case NodeType::FuncLiteral:
        return "FuncLiteral";
    case NodeType::IntegerLiteral:
        return "IntegerLiteral";
    case NodeType::MapLiteral:
        return "MapLiteral";
    case NodeType::NullLiteral:
        return "NullLiteral";
    case NodeType::SetLiteral:
        return "SetLiteral";
    case NodeType::StringLiteral:
        return "StringLiteral";
    case NodeType::SymbolLiteral:
        return "SymbolLiteral";
    case NodeType::TupleLiteral:
        return "TupleLiteral";
    case NodeType::ReturnExpr:
        return "ReturnExpr";
    case NodeType::StringSequenceExpr:
        return "StringSequenceExpr";
    case NodeType::TupleMemberExpr:
        return "TupleMemberExpr";
    case NodeType::UnaryExpr:
        return "UnaryExpr";
    case NodeType::VarExpr:
        return "VarExpr";
    case NodeType::ExprList:
        return "ExprList";
    case NodeType::File:
        return "File";
    case NodeType::MapEntry:
        return "MapEntry";
    case NodeType::MapEntryList:
        return "MapEntryList";
    case NodeType::NodeList:
        return "NodeList";
    case NodeType::ParamList:
        return "ParamList";
    case NodeType::Root:
        return "Root";
    case NodeType::AssertStmt:
        return "AssertStmt";
    case NodeType::DeclStmt:
        return "DeclStmt";
    case NodeType::EmptyStmt:
        return "EmptyStmt";
    case NodeType::ExprStmt:
        return "ExprStmt";
    case NodeType::ForStmt:
        return "ForStmt";
    case NodeType::WhileStmt:
        return "WhileStmt";
    case NodeType::StmtList:
        return "StmtList";
    case NodeType::VarList:
        return "VarList";
    }
    HAMMER_UNREACHABLE("Invalid node type.");
}

Binding::Binding(NodeType child_type)
    : Node(child_type)
    , init_() {
    HAMMER_ASSERT(child_type >= NodeType::FirstBinding
                      && child_type <= NodeType::LastBinding,
        "Invalid child type.");
}

Binding::~Binding() {}

void Binding::init(Expr* value) {
    init_.reset(value);
}

Expr* Binding::init() const {
    return init_;
}

TupleBinding::TupleBinding()
    : Binding(NodeType::TupleBinding)
    , vars_() {}

TupleBinding::~TupleBinding() {}

void TupleBinding::vars(VarList* value) {
    vars_.reset(value);
}

VarList* TupleBinding::vars() const {
    return vars_;
}

VarBinding::VarBinding()
    : Binding(NodeType::VarBinding)
    , var_() {}

VarBinding::~VarBinding() {}

void VarBinding::var(VarDecl* value) {
    var_.reset(value);
}

VarDecl* VarBinding::var() const {
    return var_;
}

BindingList::BindingList()
    : Node(NodeType::BindingList) {}

BindingList::~BindingList() {}

Decl::Decl(NodeType child_type)
    : Node(child_type)
    , name_()
    , declared_symbol_() {
    HAMMER_ASSERT(
        child_type >= NodeType::FirstDecl && child_type <= NodeType::LastDecl,
        "Invalid child type.");
}

Decl::~Decl() {}

void Decl::name(const InternedString& value) {
    name_ = value;
}

const InternedString& Decl::name() const {
    return name_;
}

void Decl::declared_symbol(SymbolEntryPtr value) {
    declared_symbol_ = value;
}

SymbolEntryPtr Decl::declared_symbol() const {
    return declared_symbol_.lock();
}

FuncDecl::FuncDecl()
    : Decl(NodeType::FuncDecl)
    , params_()
    , body_()
    , param_scope_()
    , body_scope_() {}

FuncDecl::~FuncDecl() {}

void FuncDecl::params(ParamList* value) {
    params_.reset(value);
}

ParamList* FuncDecl::params() const {
    return params_;
}

void FuncDecl::body(Expr* value) {
    body_.reset(value);
}

Expr* FuncDecl::body() const {
    return body_;
}

void FuncDecl::param_scope(ScopePtr value) {
    param_scope_ = value;
}

ScopePtr FuncDecl::param_scope() const {
    return param_scope_.lock();
}

void FuncDecl::body_scope(ScopePtr value) {
    body_scope_ = value;
}

ScopePtr FuncDecl::body_scope() const {
    return body_scope_.lock();
}

ImportDecl::ImportDecl()
    : Decl(NodeType::ImportDecl)
    , path_elements_() {}

ImportDecl::~ImportDecl() {}

ParamDecl::ParamDecl()
    : Decl(NodeType::ParamDecl) {}

ParamDecl::~ParamDecl() {}

VarDecl::VarDecl()
    : Decl(NodeType::VarDecl)
    , is_const_() {}

VarDecl::~VarDecl() {}

void VarDecl::is_const(const bool& value) {
    is_const_ = value;
}

const bool& VarDecl::is_const() const {
    return is_const_;
}

Expr::Expr(NodeType child_type)
    : Node(child_type)
    , expr_type_(ExprType::None)
    , observed_(true) {
    HAMMER_ASSERT(
        child_type >= NodeType::FirstExpr && child_type <= NodeType::LastExpr,
        "Invalid child type.");
}

Expr::~Expr() {}

void Expr::expr_type(const ExprType& value) {
    expr_type_ = value;
}

const ExprType& Expr::expr_type() const {
    return expr_type_;
}

void Expr::observed(const bool& value) {
    observed_ = value;
}

const bool& Expr::observed() const {
    return observed_;
}

BinaryExpr::BinaryExpr(BinaryOperator operation)
    : Expr(NodeType::BinaryExpr)
    , operation_(std::move(operation))
    , left_()
    , right_() {}

BinaryExpr::~BinaryExpr() {}

void BinaryExpr::operation(const BinaryOperator& value) {
    operation_ = value;
}

const BinaryOperator& BinaryExpr::operation() const {
    return operation_;
}

void BinaryExpr::left(Expr* value) {
    left_.reset(value);
}

Expr* BinaryExpr::left() const {
    return left_;
}

void BinaryExpr::right(Expr* value) {
    right_.reset(value);
}

Expr* BinaryExpr::right() const {
    return right_;
}

BlockExpr::BlockExpr()
    : Expr(NodeType::BlockExpr)
    , stmts_()
    , block_scope_() {}

BlockExpr::~BlockExpr() {}

void BlockExpr::stmts(StmtList* value) {
    stmts_.reset(value);
}

StmtList* BlockExpr::stmts() const {
    return stmts_;
}

void BlockExpr::block_scope(ScopePtr value) {
    block_scope_ = value;
}

ScopePtr BlockExpr::block_scope() const {
    return block_scope_.lock();
}

BreakExpr::BreakExpr()
    : Expr(NodeType::BreakExpr) {}

BreakExpr::~BreakExpr() {}

CallExpr::CallExpr()
    : Expr(NodeType::CallExpr)
    , func_()
    , args_() {}

CallExpr::~CallExpr() {}

void CallExpr::func(Expr* value) {
    func_.reset(value);
}

Expr* CallExpr::func() const {
    return func_;
}

void CallExpr::args(ExprList* value) {
    args_.reset(value);
}

ExprList* CallExpr::args() const {
    return args_;
}

ContinueExpr::ContinueExpr()
    : Expr(NodeType::ContinueExpr) {}

ContinueExpr::~ContinueExpr() {}

DotExpr::DotExpr()
    : Expr(NodeType::DotExpr)
    , inner_()
    , name_() {}

DotExpr::~DotExpr() {}

void DotExpr::inner(Expr* value) {
    inner_.reset(value);
}

Expr* DotExpr::inner() const {
    return inner_;
}

void DotExpr::name(const InternedString& value) {
    name_ = value;
}

const InternedString& DotExpr::name() const {
    return name_;
}

IfExpr::IfExpr()
    : Expr(NodeType::IfExpr)
    , condition_()
    , then_branch_()
    , else_branch_() {}

IfExpr::~IfExpr() {}

void IfExpr::condition(Expr* value) {
    condition_.reset(value);
}

Expr* IfExpr::condition() const {
    return condition_;
}

void IfExpr::then_branch(Expr* value) {
    then_branch_.reset(value);
}

Expr* IfExpr::then_branch() const {
    return then_branch_;
}

void IfExpr::else_branch(Expr* value) {
    else_branch_.reset(value);
}

Expr* IfExpr::else_branch() const {
    return else_branch_;
}

IndexExpr::IndexExpr()
    : Expr(NodeType::IndexExpr)
    , inner_()
    , index_() {}

IndexExpr::~IndexExpr() {}

void IndexExpr::inner(Expr* value) {
    inner_.reset(value);
}

Expr* IndexExpr::inner() const {
    return inner_;
}

void IndexExpr::index(Expr* value) {
    index_.reset(value);
}

Expr* IndexExpr::index() const {
    return index_;
}

Literal::Literal(NodeType child_type)
    : Expr(child_type) {
    HAMMER_ASSERT(child_type >= NodeType::FirstLiteral
                      && child_type <= NodeType::LastLiteral,
        "Invalid child type.");
}

Literal::~Literal() {}

ArrayLiteral::ArrayLiteral()
    : Literal(NodeType::ArrayLiteral)
    , entries_() {}

ArrayLiteral::~ArrayLiteral() {}

void ArrayLiteral::entries(ExprList* value) {
    entries_.reset(value);
}

ExprList* ArrayLiteral::entries() const {
    return entries_;
}

BooleanLiteral::BooleanLiteral(bool value)
    : Literal(NodeType::BooleanLiteral)
    , value_(std::move(value)) {}

BooleanLiteral::~BooleanLiteral() {}

void BooleanLiteral::value(const bool& value) {
    value_ = value;
}

const bool& BooleanLiteral::value() const {
    return value_;
}

FloatLiteral::FloatLiteral(f64 value)
    : Literal(NodeType::FloatLiteral)
    , value_(std::move(value)) {}

FloatLiteral::~FloatLiteral() {}

void FloatLiteral::value(const f64& value) {
    value_ = value;
}

const f64& FloatLiteral::value() const {
    return value_;
}

FuncLiteral::FuncLiteral()
    : Literal(NodeType::FuncLiteral)
    , func_() {}

FuncLiteral::~FuncLiteral() {}

void FuncLiteral::func(FuncDecl* value) {
    func_.reset(value);
}

FuncDecl* FuncLiteral::func() const {
    return func_;
}

IntegerLiteral::IntegerLiteral(i64 value)
    : Literal(NodeType::IntegerLiteral)
    , value_(std::move(value)) {}

IntegerLiteral::~IntegerLiteral() {}

void IntegerLiteral::value(const i64& value) {
    value_ = value;
}

const i64& IntegerLiteral::value() const {
    return value_;
}

MapLiteral::MapLiteral()
    : Literal(NodeType::MapLiteral)
    , entries_() {}

MapLiteral::~MapLiteral() {}

void MapLiteral::entries(MapEntryList* value) {
    entries_.reset(value);
}

MapEntryList* MapLiteral::entries() const {
    return entries_;
}

NullLiteral::NullLiteral()
    : Literal(NodeType::NullLiteral) {}

NullLiteral::~NullLiteral() {}

SetLiteral::SetLiteral()
    : Literal(NodeType::SetLiteral)
    , entries_() {}

SetLiteral::~SetLiteral() {}

void SetLiteral::entries(ExprList* value) {
    entries_.reset(value);
}

ExprList* SetLiteral::entries() const {
    return entries_;
}

StringLiteral::StringLiteral(InternedString value)
    : Literal(NodeType::StringLiteral)
    , value_(std::move(value)) {}

StringLiteral::~StringLiteral() {}

void StringLiteral::value(const InternedString& value) {
    value_ = value;
}

const InternedString& StringLiteral::value() const {
    return value_;
}

SymbolLiteral::SymbolLiteral(InternedString value)
    : Literal(NodeType::SymbolLiteral)
    , value_(std::move(value)) {}

SymbolLiteral::~SymbolLiteral() {}

void SymbolLiteral::value(const InternedString& value) {
    value_ = value;
}

const InternedString& SymbolLiteral::value() const {
    return value_;
}

TupleLiteral::TupleLiteral()
    : Literal(NodeType::TupleLiteral)
    , entries_() {}

TupleLiteral::~TupleLiteral() {}

void TupleLiteral::entries(ExprList* value) {
    entries_.reset(value);
}

ExprList* TupleLiteral::entries() const {
    return entries_;
}

ReturnExpr::ReturnExpr()
    : Expr(NodeType::ReturnExpr)
    , inner_() {}

ReturnExpr::~ReturnExpr() {}

void ReturnExpr::inner(Expr* value) {
    inner_.reset(value);
}

Expr* ReturnExpr::inner() const {
    return inner_;
}

StringSequenceExpr::StringSequenceExpr()
    : Expr(NodeType::StringSequenceExpr)
    , strings_() {}

StringSequenceExpr::~StringSequenceExpr() {}

void StringSequenceExpr::strings(ExprList* value) {
    strings_.reset(value);
}

ExprList* StringSequenceExpr::strings() const {
    return strings_;
}

TupleMemberExpr::TupleMemberExpr()
    : Expr(NodeType::TupleMemberExpr)
    , inner_()
    , index_() {}

TupleMemberExpr::~TupleMemberExpr() {}

void TupleMemberExpr::inner(Expr* value) {
    inner_.reset(value);
}

Expr* TupleMemberExpr::inner() const {
    return inner_;
}

void TupleMemberExpr::index(const u32& value) {
    index_ = value;
}

const u32& TupleMemberExpr::index() const {
    return index_;
}

UnaryExpr::UnaryExpr(UnaryOperator operation)
    : Expr(NodeType::UnaryExpr)
    , operation_(std::move(operation))
    , inner_() {}

UnaryExpr::~UnaryExpr() {}

void UnaryExpr::operation(const UnaryOperator& value) {
    operation_ = value;
}

const UnaryOperator& UnaryExpr::operation() const {
    return operation_;
}

void UnaryExpr::inner(Expr* value) {
    inner_.reset(value);
}

Expr* UnaryExpr::inner() const {
    return inner_;
}

VarExpr::VarExpr(InternedString name)
    : Expr(NodeType::VarExpr)
    , name_(std::move(name))
    , surrounding_scope_()
    , resolved_symbol_() {}

VarExpr::~VarExpr() {}

void VarExpr::name(const InternedString& value) {
    name_ = value;
}

const InternedString& VarExpr::name() const {
    return name_;
}

void VarExpr::surrounding_scope(ScopePtr value) {
    surrounding_scope_ = value;
}

ScopePtr VarExpr::surrounding_scope() const {
    return surrounding_scope_.lock();
}

void VarExpr::resolved_symbol(SymbolEntryPtr value) {
    resolved_symbol_ = value;
}

SymbolEntryPtr VarExpr::resolved_symbol() const {
    return resolved_symbol_.lock();
}

ExprList::ExprList()
    : Node(NodeType::ExprList) {}

ExprList::~ExprList() {}

File::File()
    : Node(NodeType::File)
    , file_name_()
    , items_()
    , file_scope_() {}

File::~File() {}

void File::file_name(const InternedString& value) {
    file_name_ = value;
}

const InternedString& File::file_name() const {
    return file_name_;
}

void File::items(NodeList* value) {
    items_.reset(value);
}

NodeList* File::items() const {
    return items_;
}

void File::file_scope(ScopePtr value) {
    file_scope_ = value;
}

ScopePtr File::file_scope() const {
    return file_scope_.lock();
}

MapEntry::MapEntry()
    : Node(NodeType::MapEntry)
    , key_()
    , value_() {}

MapEntry::~MapEntry() {}

void MapEntry::key(Expr* value) {
    key_.reset(value);
}

Expr* MapEntry::key() const {
    return key_;
}

void MapEntry::value(Expr* value) {
    value_.reset(value);
}

Expr* MapEntry::value() const {
    return value_;
}

MapEntryList::MapEntryList()
    : Node(NodeType::MapEntryList) {}

MapEntryList::~MapEntryList() {}

NodeList::NodeList()
    : Node(NodeType::NodeList) {}

NodeList::~NodeList() {}

ParamList::ParamList()
    : Node(NodeType::ParamList) {}

ParamList::~ParamList() {}

Root::Root()
    : Node(NodeType::Root)
    , file_()
    , root_scope_() {}

Root::~Root() {}

void Root::file(File* value) {
    file_.reset(value);
}

File* Root::file() const {
    return file_;
}

void Root::root_scope(ScopePtr value) {
    root_scope_ = value;
}

ScopePtr Root::root_scope() const {
    return root_scope_.lock();
}

Stmt::Stmt(NodeType child_type)
    : Node(child_type) {
    HAMMER_ASSERT(
        child_type >= NodeType::FirstStmt && child_type <= NodeType::LastStmt,
        "Invalid child type.");
}

Stmt::~Stmt() {}

AssertStmt::AssertStmt()
    : Stmt(NodeType::AssertStmt)
    , condition_()
    , message_() {}

AssertStmt::~AssertStmt() {}

void AssertStmt::condition(Expr* value) {
    condition_.reset(value);
}

Expr* AssertStmt::condition() const {
    return condition_;
}

void AssertStmt::message(StringLiteral* value) {
    message_.reset(value);
}

StringLiteral* AssertStmt::message() const {
    return message_;
}

DeclStmt::DeclStmt()
    : Stmt(NodeType::DeclStmt)
    , bindings_() {}

DeclStmt::~DeclStmt() {}

void DeclStmt::bindings(BindingList* value) {
    bindings_.reset(value);
}

BindingList* DeclStmt::bindings() const {
    return bindings_;
}

EmptyStmt::EmptyStmt()
    : Stmt(NodeType::EmptyStmt) {}

EmptyStmt::~EmptyStmt() {}

ExprStmt::ExprStmt()
    : Stmt(NodeType::ExprStmt)
    , expr_() {}

ExprStmt::~ExprStmt() {}

void ExprStmt::expr(Expr* value) {
    expr_.reset(value);
}

Expr* ExprStmt::expr() const {
    return expr_;
}

ForStmt::ForStmt()
    : Stmt(NodeType::ForStmt)
    , decl_()
    , condition_()
    , step_()
    , body_()
    , decl_scope_()
    , body_scope_() {}

ForStmt::~ForStmt() {}

void ForStmt::decl(DeclStmt* value) {
    decl_.reset(value);
}

DeclStmt* ForStmt::decl() const {
    return decl_;
}

void ForStmt::condition(Expr* value) {
    condition_.reset(value);
}

Expr* ForStmt::condition() const {
    return condition_;
}

void ForStmt::step(Expr* value) {
    step_.reset(value);
}

Expr* ForStmt::step() const {
    return step_;
}

void ForStmt::body(Expr* value) {
    body_.reset(value);
}

Expr* ForStmt::body() const {
    return body_;
}

void ForStmt::decl_scope(ScopePtr value) {
    decl_scope_ = value;
}

ScopePtr ForStmt::decl_scope() const {
    return decl_scope_.lock();
}

void ForStmt::body_scope(ScopePtr value) {
    body_scope_ = value;
}

ScopePtr ForStmt::body_scope() const {
    return body_scope_.lock();
}

WhileStmt::WhileStmt()
    : Stmt(NodeType::WhileStmt)
    , condition_()
    , body_()
    , body_scope_() {}

WhileStmt::~WhileStmt() {}

void WhileStmt::condition(Expr* value) {
    condition_.reset(value);
}

Expr* WhileStmt::condition() const {
    return condition_;
}

void WhileStmt::body(BlockExpr* value) {
    body_.reset(value);
}

BlockExpr* WhileStmt::body() const {
    return body_;
}

void WhileStmt::body_scope(ScopePtr value) {
    body_scope_ = value;
}

ScopePtr WhileStmt::body_scope() const {
    return body_scope_.lock();
}

StmtList::StmtList()
    : Node(NodeType::StmtList) {}

StmtList::~StmtList() {}

VarList::VarList()
    : Node(NodeType::VarList) {}

VarList::~VarList() {}

} // namespace hammer::compiler
