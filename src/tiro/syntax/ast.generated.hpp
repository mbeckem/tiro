// Automatically generated by ./utils/generate-ast at 2020-04-03 21:53:16.671399.
// Do not include this file directly and do not edit by hand!

namespace tiro {

class ASTStmt;
class ArrayLiteral;
class AssertStmt;
class BinaryExpr;
class Binding;
class BindingList;
class BlockExpr;
class BooleanLiteral;
class BreakExpr;
class CallExpr;
class ContinueExpr;
class Decl;
class DeclStmt;
class DotExpr;
class EmptyStmt;
class Expr;
class ExprList;
class ExprStmt;
class File;
class FloatLiteral;
class ForStmt;
class FuncDecl;
class FuncLiteral;
class IfExpr;
class ImportDecl;
class IndexExpr;
class IntegerLiteral;
class InterpolatedStringExpr;
class Literal;
class MapEntry;
class MapEntryList;
class MapLiteral;
class Node;
class NodeList;
class NullLiteral;
class ParamDecl;
class ParamList;
class ReturnExpr;
class Root;
class SetLiteral;
class StmtList;
class StringLiteral;
class StringSequenceExpr;
class SymbolLiteral;
class TupleBinding;
class TupleLiteral;
class TupleMemberExpr;
class UnaryExpr;
class VarBinding;
class VarDecl;
class VarExpr;
class VarList;
class WhileStmt;

enum class NodeType : int {
    AssertStmt = 1,
    DeclStmt = 2,
    EmptyStmt = 3,
    ExprStmt = 4,
    ForStmt = 5,
    WhileStmt = 6,
    FirstASTStmt = 1,
    LastASTStmt = 6,
    TupleBinding = 7,
    VarBinding = 8,
    FirstBinding = 7,
    LastBinding = 8,
    BindingList = 9,
    FuncDecl = 10,
    ImportDecl = 11,
    ParamDecl = 12,
    VarDecl = 13,
    FirstDecl = 10,
    LastDecl = 13,
    BinaryExpr = 14,
    BlockExpr = 15,
    BreakExpr = 16,
    CallExpr = 17,
    ContinueExpr = 18,
    DotExpr = 19,
    IfExpr = 20,
    IndexExpr = 21,
    InterpolatedStringExpr = 22,
    ArrayLiteral = 23,
    BooleanLiteral = 24,
    FloatLiteral = 25,
    FuncLiteral = 26,
    IntegerLiteral = 27,
    MapLiteral = 28,
    NullLiteral = 29,
    SetLiteral = 30,
    StringLiteral = 31,
    SymbolLiteral = 32,
    TupleLiteral = 33,
    FirstLiteral = 23,
    LastLiteral = 33,
    ReturnExpr = 34,
    StringSequenceExpr = 35,
    TupleMemberExpr = 36,
    UnaryExpr = 37,
    VarExpr = 38,
    FirstExpr = 14,
    LastExpr = 38,
    ExprList = 39,
    File = 40,
    MapEntry = 41,
    MapEntryList = 42,
    NodeList = 43,
    ParamList = 44,
    Root = 45,
    StmtList = 46,
    VarList = 47,
    FirstNode = 1,
    LastNode = 47
};

class ASTStmt : public Node {
protected:
    explicit ASTStmt(NodeType child_type);

public:
    ~ASTStmt();

private:
};

class AssertStmt final : public ASTStmt {
public:
    explicit AssertStmt();
    ~AssertStmt();

    void condition(Expr* value);
    Expr* condition() const;

    // optional, either interpolated string or string literal
    void message(Expr* value);
    Expr* message() const;

private:
    NodePtr<Expr> condition_;
    NodePtr<Expr> message_;
};

class DeclStmt final : public ASTStmt {
public:
    explicit DeclStmt();
    ~DeclStmt();

    void bindings(BindingList* value);
    BindingList* bindings() const;

private:
    NodePtr<BindingList> bindings_;
};

class EmptyStmt final : public ASTStmt {
public:
    explicit EmptyStmt();
    ~EmptyStmt();

private:
};

class ExprStmt final : public ASTStmt {
public:
    explicit ExprStmt();
    ~ExprStmt();

    void expr(Expr* value);
    Expr* expr() const;

private:
    NodePtr<Expr> expr_;
};

class ForStmt final : public ASTStmt {
public:
    explicit ForStmt();
    ~ForStmt();

    // optional
    void decl(DeclStmt* value);
    DeclStmt* decl() const;

    // optional
    void condition(Expr* value);
    Expr* condition() const;

    // optional
    void step(Expr* value);
    Expr* step() const;

    void body(Expr* value);
    Expr* body() const;

    void decl_scope(ScopePtr value);
    ScopePtr decl_scope() const;

    void body_scope(ScopePtr value);
    ScopePtr body_scope() const;

private:
    NodePtr<DeclStmt> decl_;
    NodePtr<Expr> condition_;
    NodePtr<Expr> step_;
    NodePtr<Expr> body_;
    WeakScopePtr decl_scope_;
    WeakScopePtr body_scope_;
};

class WhileStmt final : public ASTStmt {
public:
    explicit WhileStmt();
    ~WhileStmt();

    void condition(Expr* value);
    Expr* condition() const;

    void body(BlockExpr* value);
    BlockExpr* body() const;

    void body_scope(ScopePtr value);
    ScopePtr body_scope() const;

private:
    NodePtr<Expr> condition_;
    NodePtr<BlockExpr> body_;
    WeakScopePtr body_scope_;
};

class Binding : public Node {
protected:
    explicit Binding(NodeType child_type);

public:
    ~Binding();

    void init(Expr* value);
    Expr* init() const;

private:
    NodePtr<Expr> init_;
};

class TupleBinding final : public Binding {
public:
    explicit TupleBinding();
    ~TupleBinding();

    void vars(VarList* value);
    VarList* vars() const;

private:
    NodePtr<VarList> vars_;
};

class VarBinding final : public Binding {
public:
    explicit VarBinding();
    ~VarBinding();

    void var(VarDecl* value);
    VarDecl* var() const;

private:
    NodePtr<VarDecl> var_;
};

class BindingList final : public Node, public NodeListBase<Binding> {
public:
    explicit BindingList();
    ~BindingList();

private:
};

class Decl : public Node {
protected:
    explicit Decl(NodeType child_type);

public:
    ~Decl();

    // invalid if anonymous
    void name(const InternedString& value);
    const InternedString& name() const;

    void declared_symbol(SymbolPtr value);
    SymbolPtr declared_symbol() const;

private:
    InternedString name_;
    WeakSymbolPtr declared_symbol_;
};

class FuncDecl final : public Decl {
public:
    explicit FuncDecl();
    ~FuncDecl();

    void params(ParamList* value);
    ParamList* params() const;

    void body(Expr* value);
    Expr* body() const;

    void param_scope(ScopePtr value);
    ScopePtr param_scope() const;

    void body_scope(ScopePtr value);
    ScopePtr body_scope() const;

private:
    NodePtr<ParamList> params_;
    NodePtr<Expr> body_;
    WeakScopePtr param_scope_;
    WeakScopePtr body_scope_;
};

class ImportDecl final : public Decl {
public:
    explicit ImportDecl();
    ~ImportDecl();

    std::vector<InternedString>& path_elements() { return path_elements_; }

private:
    std::vector<InternedString> path_elements_;
};

class ParamDecl final : public Decl {
public:
    explicit ParamDecl();
    ~ParamDecl();

private:
};

class VarDecl final : public Decl {
public:
    explicit VarDecl();
    ~VarDecl();

    void is_const(const bool& value);
    const bool& is_const() const;

private:
    bool is_const_;
};

class Expr : public Node {
protected:
    explicit Expr(NodeType child_type);

public:
    ~Expr();

    void expr_type(const ExprType& value);
    const ExprType& expr_type() const;

    void surrounding_scope(ScopePtr value);
    ScopePtr surrounding_scope() const;

private:
    ExprType expr_type_;
    WeakScopePtr surrounding_scope_;
};

class BinaryExpr final : public Expr {
public:
    explicit BinaryExpr(BinaryOperator operation);
    ~BinaryExpr();

    void operation(const BinaryOperator& value);
    const BinaryOperator& operation() const;

    void left(Expr* value);
    Expr* left() const;

    void right(Expr* value);
    Expr* right() const;

private:
    BinaryOperator operation_;
    NodePtr<Expr> left_;
    NodePtr<Expr> right_;
};

class BlockExpr final : public Expr {
public:
    explicit BlockExpr();
    ~BlockExpr();

    void stmts(StmtList* value);
    StmtList* stmts() const;

    void block_scope(ScopePtr value);
    ScopePtr block_scope() const;

private:
    NodePtr<StmtList> stmts_;
    WeakScopePtr block_scope_;
};

class BreakExpr final : public Expr {
public:
    explicit BreakExpr();
    ~BreakExpr();

private:
};

class CallExpr final : public Expr {
public:
    explicit CallExpr();
    ~CallExpr();

    void func(Expr* value);
    Expr* func() const;

    void args(ExprList* value);
    ExprList* args() const;

private:
    NodePtr<Expr> func_;
    NodePtr<ExprList> args_;
};

class ContinueExpr final : public Expr {
public:
    explicit ContinueExpr();
    ~ContinueExpr();

private:
};

class DotExpr final : public Expr {
public:
    explicit DotExpr();
    ~DotExpr();

    void inner(Expr* value);
    Expr* inner() const;

    void name(const InternedString& value);
    const InternedString& name() const;

private:
    NodePtr<Expr> inner_;
    InternedString name_;
};

class IfExpr final : public Expr {
public:
    explicit IfExpr();
    ~IfExpr();

    void condition(Expr* value);
    Expr* condition() const;

    void then_branch(Expr* value);
    Expr* then_branch() const;

    void else_branch(Expr* value);
    Expr* else_branch() const;

private:
    NodePtr<Expr> condition_;
    NodePtr<Expr> then_branch_;
    NodePtr<Expr> else_branch_;
};

class IndexExpr final : public Expr {
public:
    explicit IndexExpr();
    ~IndexExpr();

    void inner(Expr* value);
    Expr* inner() const;

    void index(Expr* value);
    Expr* index() const;

private:
    NodePtr<Expr> inner_;
    NodePtr<Expr> index_;
};

class InterpolatedStringExpr final : public Expr {
public:
    explicit InterpolatedStringExpr();
    ~InterpolatedStringExpr();

    void items(ExprList* value);
    ExprList* items() const;

private:
    NodePtr<ExprList> items_;
};

class Literal : public Expr {
protected:
    explicit Literal(NodeType child_type);

public:
    ~Literal();

private:
};

class ArrayLiteral final : public Literal {
public:
    explicit ArrayLiteral();
    ~ArrayLiteral();

    void entries(ExprList* value);
    ExprList* entries() const;

private:
    NodePtr<ExprList> entries_;
};

class BooleanLiteral final : public Literal {
public:
    explicit BooleanLiteral(bool value);
    ~BooleanLiteral();

    void value(const bool& value);
    const bool& value() const;

private:
    bool value_;
};

class FloatLiteral final : public Literal {
public:
    explicit FloatLiteral(f64 value);
    ~FloatLiteral();

    void value(const f64& value);
    const f64& value() const;

private:
    f64 value_;
};

class FuncLiteral final : public Literal {
public:
    explicit FuncLiteral();
    ~FuncLiteral();

    void func(FuncDecl* value);
    FuncDecl* func() const;

private:
    NodePtr<FuncDecl> func_;
};

class IntegerLiteral final : public Literal {
public:
    explicit IntegerLiteral(i64 value);
    ~IntegerLiteral();

    void value(const i64& value);
    const i64& value() const;

private:
    i64 value_;
};

class MapLiteral final : public Literal {
public:
    explicit MapLiteral();
    ~MapLiteral();

    void entries(MapEntryList* value);
    MapEntryList* entries() const;

private:
    NodePtr<MapEntryList> entries_;
};

class NullLiteral final : public Literal {
public:
    explicit NullLiteral();
    ~NullLiteral();

private:
};

class SetLiteral final : public Literal {
public:
    explicit SetLiteral();
    ~SetLiteral();

    void entries(ExprList* value);
    ExprList* entries() const;

private:
    NodePtr<ExprList> entries_;
};

class StringLiteral final : public Literal {
public:
    explicit StringLiteral(InternedString value);
    ~StringLiteral();

    void value(const InternedString& value);
    const InternedString& value() const;

private:
    InternedString value_;
};

class SymbolLiteral final : public Literal {
public:
    explicit SymbolLiteral(InternedString value);
    ~SymbolLiteral();

    void value(const InternedString& value);
    const InternedString& value() const;

private:
    InternedString value_;
};

class TupleLiteral final : public Literal {
public:
    explicit TupleLiteral();
    ~TupleLiteral();

    void entries(ExprList* value);
    ExprList* entries() const;

private:
    NodePtr<ExprList> entries_;
};

class ReturnExpr final : public Expr {
public:
    explicit ReturnExpr();
    ~ReturnExpr();

    void inner(Expr* value);
    Expr* inner() const;

private:
    NodePtr<Expr> inner_;
};

class StringSequenceExpr final : public Expr {
public:
    explicit StringSequenceExpr();
    ~StringSequenceExpr();

    void strings(ExprList* value);
    ExprList* strings() const;

private:
    NodePtr<ExprList> strings_;
};

class TupleMemberExpr final : public Expr {
public:
    explicit TupleMemberExpr();
    ~TupleMemberExpr();

    void inner(Expr* value);
    Expr* inner() const;

    void index(const u32& value);
    const u32& index() const;

private:
    NodePtr<Expr> inner_;
    u32 index_;
};

class UnaryExpr final : public Expr {
public:
    explicit UnaryExpr(UnaryOperator operation);
    ~UnaryExpr();

    void operation(const UnaryOperator& value);
    const UnaryOperator& operation() const;

    void inner(Expr* value);
    Expr* inner() const;

private:
    UnaryOperator operation_;
    NodePtr<Expr> inner_;
};

class VarExpr final : public Expr {
public:
    explicit VarExpr(InternedString name);
    ~VarExpr();

    void name(const InternedString& value);
    const InternedString& name() const;

    void resolved_symbol(SymbolPtr value);
    SymbolPtr resolved_symbol() const;

private:
    InternedString name_;
    WeakSymbolPtr resolved_symbol_;
};

class ExprList final : public Node, public NodeListBase<Expr> {
public:
    explicit ExprList();
    ~ExprList();

private:
};

class File final : public Node {
public:
    explicit File();
    ~File();

    void file_name(const InternedString& value);
    const InternedString& file_name() const;

    // items at top level
    void items(NodeList* value);
    NodeList* items() const;

    void file_scope(ScopePtr value);
    ScopePtr file_scope() const;

private:
    InternedString file_name_;
    NodePtr<NodeList> items_;
    WeakScopePtr file_scope_;
};

class MapEntry final : public Node {
public:
    explicit MapEntry();
    ~MapEntry();

    void key(Expr* value);
    Expr* key() const;

    void value(Expr* value);
    Expr* value() const;

private:
    NodePtr<Expr> key_;
    NodePtr<Expr> value_;
};

class MapEntryList final : public Node, public NodeListBase<MapEntry> {
public:
    explicit MapEntryList();
    ~MapEntryList();

private:
};

class NodeList final : public Node, public NodeListBase<Node> {
public:
    explicit NodeList();
    ~NodeList();

private:
};

class ParamList final : public Node, public NodeListBase<ParamDecl> {
public:
    explicit ParamList();
    ~ParamList();

private:
};

class Root final : public Node {
public:
    explicit Root();
    ~Root();

    void file(File* value);
    File* file() const;

    void root_scope(ScopePtr value);
    ScopePtr root_scope() const;

private:
    NodePtr<File> file_;
    WeakScopePtr root_scope_;
};

class StmtList final : public Node, public NodeListBase<ASTStmt> {
public:
    explicit StmtList();
    ~StmtList();

private:
};

class VarList final : public Node, public NodeListBase<VarDecl> {
public:
    explicit VarList();
    ~VarList();

private:
};

template<typename Derived, typename... Arguments>
class DefaultNodeVisitor {
public:
    DefaultNodeVisitor() = default;

    TIRO_VISITOR_DECL ~DefaultNodeVisitor() = default;

    TIRO_VISITOR_DECL void visit_node(
        [[maybe_unused]] Node* node, [[maybe_unused]] Arguments... args) {}

    TIRO_VISITOR_DECL void visit_ast_stmt(
        [[maybe_unused]] ASTStmt* node, [[maybe_unused]] Arguments... args) {
        derived().visit_node(node, args...);
    }

    TIRO_VISITOR_DECL void visit_assert_stmt(
        [[maybe_unused]] AssertStmt* node, [[maybe_unused]] Arguments... args) {
        derived().visit_ast_stmt(node, args...);
    }

    TIRO_VISITOR_DECL void visit_decl_stmt(
        [[maybe_unused]] DeclStmt* node, [[maybe_unused]] Arguments... args) {
        derived().visit_ast_stmt(node, args...);
    }

    TIRO_VISITOR_DECL void visit_empty_stmt(
        [[maybe_unused]] EmptyStmt* node, [[maybe_unused]] Arguments... args) {
        derived().visit_ast_stmt(node, args...);
    }

    TIRO_VISITOR_DECL void visit_expr_stmt(
        [[maybe_unused]] ExprStmt* node, [[maybe_unused]] Arguments... args) {
        derived().visit_ast_stmt(node, args...);
    }

    TIRO_VISITOR_DECL void visit_for_stmt(
        [[maybe_unused]] ForStmt* node, [[maybe_unused]] Arguments... args) {
        derived().visit_ast_stmt(node, args...);
    }

    TIRO_VISITOR_DECL void visit_while_stmt(
        [[maybe_unused]] WhileStmt* node, [[maybe_unused]] Arguments... args) {
        derived().visit_ast_stmt(node, args...);
    }

    TIRO_VISITOR_DECL void visit_binding(
        [[maybe_unused]] Binding* node, [[maybe_unused]] Arguments... args) {
        derived().visit_node(node, args...);
    }

    TIRO_VISITOR_DECL void
    visit_tuple_binding([[maybe_unused]] TupleBinding* node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_binding(node, args...);
    }

    TIRO_VISITOR_DECL void visit_var_binding(
        [[maybe_unused]] VarBinding* node, [[maybe_unused]] Arguments... args) {
        derived().visit_binding(node, args...);
    }

    TIRO_VISITOR_DECL void
    visit_binding_list([[maybe_unused]] BindingList* node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_node(node, args...);
    }

    TIRO_VISITOR_DECL void visit_decl(
        [[maybe_unused]] Decl* node, [[maybe_unused]] Arguments... args) {
        derived().visit_node(node, args...);
    }

    TIRO_VISITOR_DECL void visit_func_decl(
        [[maybe_unused]] FuncDecl* node, [[maybe_unused]] Arguments... args) {
        derived().visit_decl(node, args...);
    }

    TIRO_VISITOR_DECL void visit_import_decl(
        [[maybe_unused]] ImportDecl* node, [[maybe_unused]] Arguments... args) {
        derived().visit_decl(node, args...);
    }

    TIRO_VISITOR_DECL void visit_param_decl(
        [[maybe_unused]] ParamDecl* node, [[maybe_unused]] Arguments... args) {
        derived().visit_decl(node, args...);
    }

    TIRO_VISITOR_DECL void visit_var_decl(
        [[maybe_unused]] VarDecl* node, [[maybe_unused]] Arguments... args) {
        derived().visit_decl(node, args...);
    }

    TIRO_VISITOR_DECL void visit_expr(
        [[maybe_unused]] Expr* node, [[maybe_unused]] Arguments... args) {
        derived().visit_node(node, args...);
    }

    TIRO_VISITOR_DECL void visit_binary_expr(
        [[maybe_unused]] BinaryExpr* node, [[maybe_unused]] Arguments... args) {
        derived().visit_expr(node, args...);
    }

    TIRO_VISITOR_DECL void visit_block_expr(
        [[maybe_unused]] BlockExpr* node, [[maybe_unused]] Arguments... args) {
        derived().visit_expr(node, args...);
    }

    TIRO_VISITOR_DECL void visit_break_expr(
        [[maybe_unused]] BreakExpr* node, [[maybe_unused]] Arguments... args) {
        derived().visit_expr(node, args...);
    }

    TIRO_VISITOR_DECL void visit_call_expr(
        [[maybe_unused]] CallExpr* node, [[maybe_unused]] Arguments... args) {
        derived().visit_expr(node, args...);
    }

    TIRO_VISITOR_DECL void
    visit_continue_expr([[maybe_unused]] ContinueExpr* node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_expr(node, args...);
    }

    TIRO_VISITOR_DECL void visit_dot_expr(
        [[maybe_unused]] DotExpr* node, [[maybe_unused]] Arguments... args) {
        derived().visit_expr(node, args...);
    }

    TIRO_VISITOR_DECL void visit_if_expr(
        [[maybe_unused]] IfExpr* node, [[maybe_unused]] Arguments... args) {
        derived().visit_expr(node, args...);
    }

    TIRO_VISITOR_DECL void visit_index_expr(
        [[maybe_unused]] IndexExpr* node, [[maybe_unused]] Arguments... args) {
        derived().visit_expr(node, args...);
    }

    TIRO_VISITOR_DECL void visit_interpolated_string_expr(
        [[maybe_unused]] InterpolatedStringExpr* node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_expr(node, args...);
    }

    TIRO_VISITOR_DECL void visit_literal(
        [[maybe_unused]] Literal* node, [[maybe_unused]] Arguments... args) {
        derived().visit_expr(node, args...);
    }

    TIRO_VISITOR_DECL void
    visit_array_literal([[maybe_unused]] ArrayLiteral* node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_literal(node, args...);
    }

    TIRO_VISITOR_DECL void
    visit_boolean_literal([[maybe_unused]] BooleanLiteral* node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_literal(node, args...);
    }

    TIRO_VISITOR_DECL void
    visit_float_literal([[maybe_unused]] FloatLiteral* node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_literal(node, args...);
    }

    TIRO_VISITOR_DECL void
    visit_func_literal([[maybe_unused]] FuncLiteral* node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_literal(node, args...);
    }

    TIRO_VISITOR_DECL void
    visit_integer_literal([[maybe_unused]] IntegerLiteral* node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_literal(node, args...);
    }

    TIRO_VISITOR_DECL void visit_map_literal(
        [[maybe_unused]] MapLiteral* node, [[maybe_unused]] Arguments... args) {
        derived().visit_literal(node, args...);
    }

    TIRO_VISITOR_DECL void
    visit_null_literal([[maybe_unused]] NullLiteral* node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_literal(node, args...);
    }

    TIRO_VISITOR_DECL void visit_set_literal(
        [[maybe_unused]] SetLiteral* node, [[maybe_unused]] Arguments... args) {
        derived().visit_literal(node, args...);
    }

    TIRO_VISITOR_DECL void
    visit_string_literal([[maybe_unused]] StringLiteral* node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_literal(node, args...);
    }

    TIRO_VISITOR_DECL void
    visit_symbol_literal([[maybe_unused]] SymbolLiteral* node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_literal(node, args...);
    }

    TIRO_VISITOR_DECL void
    visit_tuple_literal([[maybe_unused]] TupleLiteral* node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_literal(node, args...);
    }

    TIRO_VISITOR_DECL void visit_return_expr(
        [[maybe_unused]] ReturnExpr* node, [[maybe_unused]] Arguments... args) {
        derived().visit_expr(node, args...);
    }

    TIRO_VISITOR_DECL void
    visit_string_sequence_expr([[maybe_unused]] StringSequenceExpr* node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_expr(node, args...);
    }

    TIRO_VISITOR_DECL void
    visit_tuple_member_expr([[maybe_unused]] TupleMemberExpr* node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_expr(node, args...);
    }

    TIRO_VISITOR_DECL void visit_unary_expr(
        [[maybe_unused]] UnaryExpr* node, [[maybe_unused]] Arguments... args) {
        derived().visit_expr(node, args...);
    }

    TIRO_VISITOR_DECL void visit_var_expr(
        [[maybe_unused]] VarExpr* node, [[maybe_unused]] Arguments... args) {
        derived().visit_expr(node, args...);
    }

    TIRO_VISITOR_DECL void visit_expr_list(
        [[maybe_unused]] ExprList* node, [[maybe_unused]] Arguments... args) {
        derived().visit_node(node, args...);
    }

    TIRO_VISITOR_DECL void visit_file(
        [[maybe_unused]] File* node, [[maybe_unused]] Arguments... args) {
        derived().visit_node(node, args...);
    }

    TIRO_VISITOR_DECL void visit_map_entry(
        [[maybe_unused]] MapEntry* node, [[maybe_unused]] Arguments... args) {
        derived().visit_node(node, args...);
    }

    TIRO_VISITOR_DECL void
    visit_map_entry_list([[maybe_unused]] MapEntryList* node,
        [[maybe_unused]] Arguments... args) {
        derived().visit_node(node, args...);
    }

    TIRO_VISITOR_DECL void visit_node_list(
        [[maybe_unused]] NodeList* node, [[maybe_unused]] Arguments... args) {
        derived().visit_node(node, args...);
    }

    TIRO_VISITOR_DECL void visit_param_list(
        [[maybe_unused]] ParamList* node, [[maybe_unused]] Arguments... args) {
        derived().visit_node(node, args...);
    }

    TIRO_VISITOR_DECL void visit_root(
        [[maybe_unused]] Root* node, [[maybe_unused]] Arguments... args) {
        derived().visit_node(node, args...);
    }

    TIRO_VISITOR_DECL void visit_stmt_list(
        [[maybe_unused]] StmtList* node, [[maybe_unused]] Arguments... args) {
        derived().visit_node(node, args...);
    }

    TIRO_VISITOR_DECL void visit_var_list(
        [[maybe_unused]] VarList* node, [[maybe_unused]] Arguments... args) {
        derived().visit_node(node, args...);
    }

private:
    Derived& derived() { return static_cast<Derived&>(*this); }
};

} // namespace tiro
