#ifndef TIRO_API_H
#define TIRO_API_H

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>

#ifdef __cplusplus
extern "C" {
#endif

#if defined(_WIN32) || defined(__CYGWIN__)
#    ifdef TIRO_BUILDING_DLL
#        ifdef __GNUC__
#            define TIRO_API __attribute__((dllexport))
#        else
#            define TIRO_API __declspec(dllexport)
#        endif
#    else
#        ifdef __GNUC__
#            define TIRO_API __attribute__((dllimport))
#        else
#            define TIRO_API __declspec(dllimport)
#        endif
#    endif
#else
#    define TIRO_API __attribute__((visibility("default")))
#endif

#if defined(__GNUC__) || defined(__clang__)
#    define TIRO_WARN_UNUSED __attribute__((warn_unused_result))
#elif defined(_MSC_VER)
#    define TIRO_WARN_UNUSED _Check_return_
#else
#    define TIRO_WARN_UNUSED
#endif

/**
 * Tiro uses semantic versioning. The version number is incremented for every api change.
 * The following macro constructs a single version number by combining the major, minor and
 * patch version parts. The final version number supports comparison through relational operators.
 * 
 * Note that the individual version number parts must be smaller than 1000.
 */
#define TIRO_MAKE_VERSION(major, minor, patch) \
    (uint32_t)((major) *1000000 + (minor) *1000 + (patch))

/* clang-format off */

/** 
 * The compile time version of this library, as a number.
 */
#define TIRO_VERSION_NUMBER TIRO_MAKE_VERSION(@PROJECT_VERSION_MAJOR@, @PROJECT_VERSION_MINOR@, @PROJECT_VERSION_PATCH@)

/** 
 * The compile time version of this library, as a human readable string.
 */
#define TIRO_VERSION "@PROJECT_VERSION@"

/* clang-format on */

/** 
 * Returns the value of `TIRO_VERSION_NUMBER` at the time the library was built. This may be different
 * than the value observed in `TIRO_VERSION_NUMBER` if the application uses a different library version
 * than it was originally compiled with.
 */
uint32_t tiro_version_number();

/** 
 * The value of `TIRO_VERSION` at the time the library was built. The returned string points into static storage
 * and must not be modified.
 */
const char* tiro_version();

typedef struct tiro_compiler tiro_compiler;
typedef struct tiro_module tiro_module;
typedef struct tiro_frame tiro_frame;
typedef struct tiro_value tiro_value;
typedef tiro_value* tiro_handle;

/**
 * Defines all possible error codes.
 */
typedef enum tiro_errc {
    TIRO_OK = 0,
    TIRO_ERROR_BAD_STATE,          /* Instance is not in the correct state */
    TIRO_ERROR_BAD_ARG,            /* Invalid argument */
    TIRO_ERROR_BAD_SOURCE,         /* Invalid source code */
    TIRO_ERROR_BAD_TYPE,           /* Operation not supported on type */
    TIRO_ERROR_MODULE_EXISTS,      /* Module name defined more than once */
    TIRO_ERROR_MODULE_NOT_FOUND,   /* Requested module does not exist */
    TIRO_ERROR_FUNCTION_NOT_FOUND, /* Requested function does not exist */
    TIRO_ERROR_OUT_OF_BOUNDS,      /* Argument was out of bounds */
    TIRO_ERROR_ALLOC,              /* Allocation failure */
    TIRO_ERROR_INTERNAL = 1000,    /* Internal error */
} tiro_errc;

/**
 * Returns the name of the given error code.
 * The string points into static storage and must not be freed.
 */
TIRO_API const char* tiro_errc_name(tiro_errc e);

/**
 * Returns a human readable description of the given error code.
 * The string points into static storage and must not be freed.
 */
TIRO_API const char* tiro_errc_message(tiro_errc e);

/**
 * Represents an execution error within an api function. Objects of this type
 * may contains rich error information such as a detailed error message
 * or file/line information where the error occurred (in debug builds).
 *
 * The general error handling approach in this library is as follows:
 *
 * All API functions that may fail return an `tiro_errc` value to indicate
 * success or error. The exception to this scheme are functions that simply allocate memory - those
 * return a NULL pointer on error.
 *
 * An additional argument of type `tiro_error**` may be provided by the caller to obtain
 * detailed error information. This argument is always optional and may simply be `NULL`
 * if not needed. When an api function reports an error, the `tiro_error` will be initialized
 * and must be checked (and freed!) by the caller.
 *
 *  Example:
 *      tiro_error* error = NULL;                               // Initialize to NULL
 *      if ((operation_may_fail(arg, &error)) != TIRO_OK) {     // Pass &error for details
 *          report_operation_error(error);
 *          tiro_error_free(error);
 *      }
 */
typedef struct tiro_error tiro_error;

/**
 * Frees the given error instance. Does nothing if `err` is NULL.
 */
TIRO_API void tiro_error_free(tiro_error* err);

/**
 * Returns the error code stored in the given error.
 * Returns `TIRO_OK` if `err` is NULL.
 */
TIRO_API tiro_errc tiro_error_errc(const tiro_error* err);

/**
 * Returns the name of the error code in the given error.
 */
TIRO_API const char* tiro_error_name(const tiro_error* err);

/**
 * Returns the human readable message of the error code in the given error.
 */
TIRO_API const char* tiro_error_message(const tiro_error* err);

/**
 * Returns detailed error information as a human readable string.
 * The string will never be null, but it may be empty if detailed information
 * are not available.
 * 
 * The returned string is managed by the error and will remain valid for
 * as long as the error is not modified or freed.
 */
TIRO_API const char* tiro_error_details(const tiro_error* err);

/**
 * Defines the possible values for the severity of diagnostic compiler messages.
 */
typedef enum tiro_severity {
    TIRO_SEVERITY_WARNING = 1, /* A compiler warning */
    TIRO_SEVERITY_ERROR,       /* A compiler error (compilation fails) */
} tiro_severity;

/**
 * Returns the string representation of the given severity value.
 * The returned string is allocated in static storage and MUST NOT
 * be freed.
 */
TIRO_API const char* tiro_severity_str(tiro_severity severity);

/**
 * The tiro_vm_settings structure can be provided to `tiro_vm_new` as a
 * configuration parameter.
 * Use tiro_vm_settings_init to initialize this struct to default values.
 */
typedef struct tiro_vm_settings {
    /* TODO */
    int _not_empty_; /* prevent size 0 warning (clang) */
} tiro_vm_settings;

/**
 * Initializes the given tiro settings object with default values.
 */
TIRO_API void tiro_vm_settings_init(tiro_vm_settings* settings);

/**
 * An instance of the tiro virtual machine. All virtual machines
 * are isolated from each other.
 */
typedef struct tiro_vm tiro_vm;

/**
 * Allocates a new virtual machine instance.
 * Reads settings from the given `settings` objects, if it is not NULL.
 * Otherwise uses default values.
 *
 * Returns NULL on allocation failure.
 */
TIRO_API TIRO_WARN_UNUSED tiro_vm* tiro_vm_new(const tiro_vm_settings* settings);

/**
 * Free a virtual machine. Must be called exactly once
 * for every vm created with `tiro_vm_new`.
 *
 * Does nothing if `vm` is NULL.
 */
TIRO_API void tiro_vm_free(tiro_vm* vm);

/**
 * Load the default modules provided by the runtime.
 *
 * TODO: Configuration?
 */
TIRO_API tiro_errc tiro_vm_load_std(tiro_vm* vm, tiro_error** err);

/**
 * Loads the compiled module into virtual machine.
 */
TIRO_API tiro_errc tiro_vm_load(tiro_vm* vm, const tiro_module* module, tiro_error** err);

/**
 * Attempts to run the given function with the given name, in the specified module.
 * The return value (if any) will be placed into the `result` pointer, which must not be NULL.
 * The string must be passed to `free` to release memory.
 *
 * TODO: This is a temporary api. We need a real value representation and should
 * consider exported functions.
 * 
 * TODO: This API will eventually be asynchronous!
 */
TIRO_API tiro_errc tiro_vm_run(tiro_vm* vm, const char* module_name, const char* function_name,
    char** result, tiro_error** err);

/**
 * Attempts to find the exported function with the given name in the specified module. The found function value
 * will be stored in the `result` handle, which must not be NULL.
 * 
 * Returns `TIRO_ERROR_MODULE_NOT_FOUND` if the specified module was not loaded.
 * Returns `TIRO_ERROR_FUNCTION_NOT_FOUND` if the module does not contain the requested function.
 */
TIRO_API tiro_errc tiro_vm_find_function(tiro_vm* vm, const char* module_name,
    const char* function_name, tiro_handle result, tiro_error** err);

/**
 * Calls the given function and places the function's return value into `result` (if present).
 * 
 * \param vm        The virtual machine instance.
 * \param function  The function to call. Must not be NULL.
 * \param arguments The function call arguments. Must be a tuple if arguments shall be passed, or a null value or NULL pointer
 *                  to indicate zero arguments.
 * \param result    A handle in which the function's return value will be placed. Can be NULL.
 * \param err       An optional error handle for detailed error information. 
 */
TIRO_API tiro_errc tiro_vm_call(
    tiro_vm* vm, tiro_handle function, tiro_handle arguments, tiro_handle result, tiro_error** err);

/** 
 * Represents the kind of a tiro value.
 */
typedef enum tiro_kind {
    TIRO_KIND_NULL = 0,        /* Value is null */
    TIRO_KIND_BOOLEAN,         /* Value is true or false */
    TIRO_KIND_INTEGER,         /* Value is an integer */
    TIRO_KIND_FLOAT,           /* Value is a floating point number */
    TIRO_KIND_STRING,          /* Value is a string */
    TIRO_KIND_TUPLE,           /* Value is a tuple */
    TIRO_KIND_FUNCTION,        /* Value is a function */
    TIRO_KIND_INTERNAL = 1000, /* Value is some other, internal type */
    TIRO_KIND_INVALID,         /* Invalid value (e.g. null handle) */
} tiro_kind;

/**
 * Returns the name of the kind, formatted as a string.
 * The string points into static storage and must not be freed.
 */
TIRO_API const char* tiro_kind_str(tiro_kind kind);

/**
 * Represents a value in the tiro language.
 * 
 * Values cannot be used directly through the API. Instead, all operations on values must
 * be done through a `tiro_handle`. Handles are a wrapper type around a value which ensures that
 * their inner value always remains valid, even if garbage collection is triggered.
 * 
 * \warning 
 *      Handles may only be used when obtained from a function of this API (such as `tiro_frame_slot()`).
 *      They must never be initialized manually!
 * 
 * A value stored in a valid handle is always considered *live*, which means that the garbage collector
 * will not destroy it. If the garbage collector decides to move a value (which would change its address), 
 * the handles refering to that address will be updated automatically in a process that is completely transparent to the user.
 */
struct tiro_value;

/** Returns the kind of the handle's current value. */
TIRO_API tiro_kind tiro_value_kind(tiro_vm* vm, tiro_handle value);

/** Sets the given `result` handle to null. */
TIRO_API void tiro_make_null(tiro_vm* vm, tiro_handle result);

/** Returns the specified boolean value via the output argument `result`. */
TIRO_API tiro_errc tiro_make_boolean(tiro_vm* vm, bool value, tiro_handle result, tiro_error** err);

/** 
 * Returns `value` converted to a boolean value. `false` and `null` are considered false, all other values will return `true`.
 */
TIRO_API bool tiro_boolean_value(tiro_vm* vm, tiro_handle value);

/** Constructs an integer with the given value. Returns `TIRO_ERROR_ALLOC` on allocation failure. */
TIRO_API tiro_errc tiro_make_integer(
    tiro_vm* vm, int64_t value, tiro_handle result, tiro_error** err);

/** 
 * Returns `value` converted to an integer. This function supports conversion for floating point values 
 * (they are truncated to an integer). All other values return 0 (use `tiro_value_kind` to disambiguate between types).
 */
TIRO_API int64_t tiro_integer_value(tiro_vm* vm, tiro_handle value);

/** Constructs a float with the given value. Returns `TIRO_ERROR_ALLOC` on allocation failure. */
TIRO_API tiro_errc tiro_make_float(tiro_vm* vm, double value, tiro_handle result, tiro_error** err);

/**
 * Returns the floating point of `value`. This function supports conversion for integer values, all
 * other values will return 0 (use `tiro_value_kind` to disambiguate between types).
 */
TIRO_API double tiro_float_value(tiro_vm* vm, tiro_handle value);

/** Constructs a new tuple with `size` entries. All entries are initially null. Returns `TIRO_ERROR_ALLOC` on allocation failure. */
TIRO_API tiro_errc tiro_make_tuple(tiro_vm* vm, size_t size, tiro_handle result, tiro_error** err);

/** Returns the tuple's size, or 0 if the given value is not a tuple (use `tiro_value_kind` to disambiguate between types). */
TIRO_API size_t tiro_tuple_size(tiro_vm* vm, tiro_handle tuple);

/** 
 * Retrieves the tuple element with the given `index` from `tuple` and assigns it to `result`, unless an error occcurs.
 * Returns `TIRO_ERROR_BAD_TYPE` if the instance is not a tuple, or `TIRO_ERROR_OUT_OF_BOUNDS` if the index is out of bounds.
 */
TIRO_API tiro_errc tiro_tuple_get(
    tiro_vm* vm, tiro_handle tuple, size_t index, tiro_handle result, tiro_error** err);

/**
 * Sets the tuple's element at position `index` to `value`. 
 * Returns `TIRO_ERROR_BAD_TYPE` if the instance is not a tuple, or `TIRO_ERROR_OUT_OF_BOUNDS` if the index is out of bounds.
 */
TIRO_API tiro_errc tiro_tuple_set(
    tiro_vm* vm, tiro_handle tuple, size_t index, tiro_handle value, tiro_error** err);

/**
 * Represents an array of rooted values with dynamic lifetime. A frame is composed of slots, each of which
 * can hold an arbitrary value. Frames are registered with the garbage collector, so
 * their slots will be visited during collection (with their values being marked as live).
 */
struct tiro_frame;

/**
 * Constructs a new frame with the given number of slots. 
 * Frame must be destroyed by calling `tiro_frame_free`.
 * A frame belongs to its `vm` instance and must be destroyed before the vm is destroyed.
 * 
 * Returns NULL on allocation failure, or if `vm` is NULL.
 */
TIRO_API TIRO_WARN_UNUSED tiro_frame* tiro_frame_new(tiro_vm* vm, size_t slots);

/**
 * Frees a frame. Must be called exactly once for every frame created with `tiro_frame_new`.
 * 
 * Does nothing if `frame` is NULL.
 */
TIRO_API void tiro_frame_free(tiro_frame* frame);

/**
 * Returns the number of slots in this frame.
 */
TIRO_API size_t tiro_frame_size(tiro_frame* frame);

/** 
 * Returns the frame's slot at the given `slot_index` as a handle.
 * Returns NULL if the slot index is invalid.
 * 
 * All slot indices between 0 (inclusive) and `tiro_frame_size(frame)` (exclusive) can be used.
 */
TIRO_API tiro_handle tiro_frame_slot(tiro_frame* frame, size_t slot_index);

/**
 * An instance of this type can be passed to the compiler to configure it.
 * Use tiro_compiler_settings_init to initialize this struct to default values.
 */
typedef struct tiro_compiler_settings {
    /* Compiler will remember the AST, this enables the `tiro_compiler_dump_ast` function. */
    bool enable_dump_ast;

    /* Compiler will remember the IR, this enables the `tiro_compiler_dump_ir` function. */
    bool enable_dump_ir;

    /* Compiler will remember the diassembled bytecode, this enables
     * the `tiro_compiler_dump_bytecode` function. */
    bool enable_dump_bytecode;

    /* TODO: Skip codegen flag */

    /* Userdata pointer that will be passed to message_callback. Defaults to NULL. */
    void* message_callback_data;

    /* Will be invoked for every diagnostic message emitted by the compiler.
     * The default function prints messages to stdout. */
    void (*message_callback)(tiro_severity severity, uint32_t line, uint32_t column,
        const char* message, void* userdata);
} tiro_compiler_settings;

/**
 * Initializes the given compiler settings object with default values.
 */
TIRO_API void tiro_compiler_settings_init(tiro_compiler_settings* settings);

/**
 * The compiler instance translates a set of source file into a module.
 */
struct tiro_compiler;

/**
 * Allocates a new compiler instance. A compiler can be used to compile
 * a set of source files into a module. Warnings or errors emitted during
 * compilation can be observed through the `settings->message_callback` function.
 *
 * \param settings The compiler settings (optional). Default values will be used if
 * this parameter is NULL.
 *
 * FIXME: Currently only works for a single source files, implement _add api.
 */
TIRO_API TIRO_WARN_UNUSED tiro_compiler* tiro_compiler_new(const tiro_compiler_settings* settings);

/**
 * Destroys and frees the given compiler instance. Must be called exactly once
 * for every instance created via `tiro_compiler_new` in order to avoid resource leaks.
 * Does nothing if `compiler` is NULL.
 */
TIRO_API void tiro_compiler_free(tiro_compiler* compiler);

/**
 * Add a source file to the compiler. Can only be called before compilation started.
 *
 * FIXME: Can only be called for a single source file currently.
 */
TIRO_API tiro_errc tiro_compiler_add_file(
    tiro_compiler* compiler, const char* file_name, const char* file_content, tiro_error** err);

/**
 * Run the compiler on the set of source files provided via `tiro_compiler_add_file`.
 * Requires at least once source file.
 * This function can only be called once for every compiler instance.
 *
 * Returns an error if the compilation fails.
 */
TIRO_API tiro_errc tiro_compiler_run(tiro_compiler* compiler, tiro_error** err);

/**
 * Returns true if this compiler has successfully compiled a set of source files
 * and produced a bytecode module. In order for this function to return true,
 * a previous call to `tiro_compiler_run` must have returned `TIRO_OK` and
 * the compiler must have beeen configured to actually produce a module.
 */
TIRO_API
bool tiro_compiler_has_module(tiro_compiler* compiler);

/**
 * Extracts the compiled module from the compiler and returns it.
 * On success, the module will placed into the location specified by `module`, which
 * must not be NULL. If a module was returned, it must be freed by calling `tiro_module_free`.
 *
 * This function fails if `tiro_compiler_has_module` returns false.
 */
TIRO_API tiro_errc tiro_compiler_take_module(
    tiro_compiler* compiler, tiro_module** module, tiro_error** err);

/**
 * Returns the string representation of the AST.
 * Can only be called after `tiro_compiler_run` has been executed. The compile
 * process can have failed; a somewhat useful AST can often still be produced.
 *
 * Returns `TIRO_ERROR_BAD_STATE` if the compiler cannot produce the AST.
 *
 * Otherwise, this function returns `TIRO_OK` and returns a new string using the provided
 * output parameter. The string must be passed to `free` to release memory.
 */
TIRO_API tiro_errc tiro_compiler_dump_ast(tiro_compiler* compiler, char** string, tiro_error** err);

/**
 * Returns the string representation of the internal representation immediately before
 * code generation. Can only be called after `tiro_compiler_run` has been executed successfully.
 *
 * Returns `TIRO_ERROR_BAD_STATE` if the compiler cannot produce the internal representation.
 *
 * Otherwise, this function returns `TIRO_OK` and returns a new string using the provided
 * output parameter. The string must be passed to `free` to release memory.
 */
TIRO_API tiro_errc tiro_compiler_dump_ir(tiro_compiler* compiler, char** string, tiro_error** err);

/**
 * Returns the string representation of the compiled bytecode module.
 * Can only be called after `tiro_compiler_run` has been executed successfully.
 *
 * Returns `TIRO_ERROR_BAD_STATE` if the compiler cannot produce the disassembled output.
 *
 * Otherwise, this function returns `TIRO_OK` and returns a new string using the provided
 * output parameter. The string must be passed to `free` to release memory.
 */
TIRO_API tiro_errc tiro_compiler_dump_bytecode(
    tiro_compiler* compiler, char** string, tiro_error** err);

/**
 * Represents a compiled module. Modules can be loaded into a vm for execution.
 * Modules instances can be created by compiling source code using the `tiro_compiler`.
 */
struct tiro_module;

/**
 * Free a module. Must be called exactly once
 * for every created module.
 *
 * Does nothing if `module` is NULL.
 */
TIRO_API void tiro_module_free(tiro_module* module);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* TIRO_API_H */
