import std;
import std.io;

func main() {
    const listen_ip = "0.0.0.0";
    const listen_port = 12345;

    var error;

    const listener = io.new_listener();
    listener.reuse_address(true);
    error = listener.open(listen_ip, listen_port);
    if (error) {
        std.print("Failed to open listening socket:", error);
        return;
    }

    std.print("Listening on port ${listen_port}");

    var connection_id = 0;
    while (1) {
        const (socket, error) = listener.accept();
        if (error) {
            std.print("Failed to accept socket:", error);
            continue;
        }

        connection_id += 1;
        std.launch(func() {    
            handle_connection(socket, connection_id);
            socket.close();
        });
    }

    listener.close();
}

func handle_connection(socket, connection_id) {
    std.print("Connection", connection_id, "accepted from", socket.remote_endpoint());

    const header = {
        const (header, error) = read_header(socket);
        if (error) {
            if (error == #eof) {
                std.print("Connection", connection_id, "premature end of file");
            } else {
                std.print("Connection", connection_id, "read error:", error);
            }
            return;
        }

        header;
    };

    var reply = handle_request(header, socket.remote_endpoint());
    const buffer = std.to_utf8(reply);
    
    const written = {
        const (written, error) = write_all(socket, buffer, 0, buffer.size());
        if (error) {
            std.print("Connection", connection_id, "write error", error);
            return;
        }

        written;
    };

    std.print("Connection", connection_id, "done -", written, "bytes written");
}

func handle_request(request, peer_address) = {
    "HTTP/1.0 200 OK\r\n"
    "Server: tiro-demo/1.0\r\n"
    "Content-Type: text/plain; charset=UTF-8\r\n"
    "Connection: close\r\n"
    "\r\n"
    "Hello World\n\n"
    "Your address is: ${peer_address}\n\n"
    "The original request was:\n\n"
    "$request\n";
}

func read_header(socket) {
    const lines = line_reader(socket);
    const combined = std.new_string_builder();

    while (1) {
        const (line, error) = lines.next_line();
        if (error) {
            return (null, error);
        }

        if (line == "") {
            break;
        }

        combined.append(line, "\n");
    }
    return (combined.to_str(), null);
}

func line_reader(socket) {
    const bytes = byte_reader(socket);

    const lf = 10;
    const cr = 13;

    // No classes yet!
    const reader = std.new_object();
    const line = std.new_string_builder();
    reader.next_line = func() {
        var current;
        var error;
        var has_cr = false;

        while (1) {
            (current, error) = bytes.next_byte();
            if (error) {
                return (null, error);
            }

            // Line ended
            if (current == lf) {
                const str = line.to_str();
                line.clear();
                return (str, null);
            } 

            // Push buffered carriage return that did not preceed
            // a line termination
            if (has_cr) {
                line.append_byte(cr);
                has_cr = false;
            }

            if (current == cr) {
                has_cr = true;
            } else {
                line.append_byte(current);
            }
        }
    };
    return reader;
}

func byte_reader(socket) {
    const buffer_size = 4096;
    const buffer = std.new_buffer(buffer_size);

    var byte_count = 0;
    var byte_index = 0;

    // No classes yet!
    const reader = std.new_object();    
    reader.next_byte = func() {
        if (byte_index == byte_count) {
            var error;
            (byte_count, error) = socket.read(buffer, 0, buffer_size);
            if (error) {
                return (null, error);
            }

            byte_index = 0;
        }

        const byte = buffer[byte_index];
        byte_index += 1;
        return (byte, null);
    };
    return reader;
}

func write_all(socket, buffer, i, n) {
    var total = 0;
    while (total != n) {
        const (written, error) = socket.write(buffer, i + total, n - total);
        if (error) {
            return (total, error);
        }

        total += written;
    }
    return (total, null);
}
